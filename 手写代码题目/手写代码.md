# 防抖

```js
function debounce(fn, delay) {
  let timer = null
  let that = this
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(that, args)
    }, delay)
  }
}
```

# 节流

```js
function throttle(fn, delay) {
  let timer = null
  return function (...args) {
    const that = this
    if (timer) return
    timer = setTimeout(() => {
      fn.apply(that, args)
      timer = null
    }, delay)
  }
}
```

# instanceOf

```js
function instanceOf(left, right) {
  let prop = right.prototype
  left = Object.getPrototypeOf(left)
  while (left) {
    if (left === prop) return true
    left = Object.getPrototypeOf(left)
  }
  return false
}
```

# new

```js
function myNew(constructor, ...args) {
  const obj = new Object()
  Object.setPrototype(obj, constructor.prototype)
  const res = constructor.apply(obj, args)
  return res instanceof Object ? res : obj
}
```

# call apply bind

call

```js
Function.prototype.myCall = function (context = window, ...args) {
  const fn = Symbol()
  context[fn] = this
  const result = context[fn](...args)
  delete context[fn]
  return result
}
```

apply

```js
Function.prototype.myApply = function (context = window, args) {
  const fn = Symbol()
  context[fn] = this
  const result = context[fn](...args)
  delete context[fn]
  return result
}
```

bind

```js
Function.prototype.myBind = function (context = window, ...args) {
  const fn = this
  return function (...args2) {
    return fn.apply(context, [...args, ...args2])
  }
}
```

# 浅拷贝和深拷贝

浅拷贝
Array.prototype.slice
Array.prototype.concat
Object.assign({},{ab:123})

深拷贝
JSON.parse(JSON.stringify())

```js
//判断是否为object
const isObject = (obj) => typeof obj === "object" && obj !== null
function deepClone(obj, map = new WeakMap()) {
  if (!isObject(obj)) return obj
  if (map.has(obj)) return map.get(obj)
  // 获取当前值的构造函数：获取它的类型
  let constructor = obj.constructor
  // 检测当前对象target是否与正则、日期格式对象匹配
  if (/^(RegExp|Date)$/i.test(constructor.name)) {
    // 创建一个新的特殊对象(正则类/日期类)的实例
    return new constructor(obj)
  }
  const newObj = Array.isArray(obj) ? [] : {}
  map.set(obj, newObj)
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepClone(obj[key], map)
    } else {
      newObj[key] = obj[key]
    }
  }
  return newObj
}
// 测试
const obj = {
  a: 1,
  b: { c: 2 },
}
console.log(deepClone(obj))
```

# 类的继承和 ES5 继承

类的继承

```js
class Parent {
  constructor(name) {
    this.name = name
  }
  getName() {
    return this.name
  }
}
class Child extends Parent {
  constructor(name, age) {
    super(name)
    this.age = age
  }
}
```

ES5 继承（寄生组合继承）

```js
function Parent(name) {
  this.name = name
}
Parent.prototype.getName = function () {
  return this.name
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

Child.prototype = new Parent()
console.log(Child.prototype.constructor) //指向了Parent
Child.prototype.constructor = Child

function inheritPrototype(Child, Parent) {
  let prototype = Object.create(Parent.prototype)
  Child.prototype = prototype
  Child.prototype.constructor = Child
}
inheritPrototype(Child, Parent)
```

# promise

## 手写 promise

```js

```

## promisify

```js
function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, data) => {
        if (err) reject(err)
        resolve(data)
      })
    })
  }
}
// 测试
const readFile = promisify(fs.readFile)
readFile("./test.txt", "utf-8").then((data) => {
  console.log(data)
})
```

# 订阅发布

适用场景：

```js
class EventEmitter {
  constructor() {
    this.events = {}
  }

  on(event, fn) {
    if (!this.events[event]) {
      this.events[event] = []
    }
    this.events[event].push(fn)
  }

  emit(event, ...args) {
    if (!this.events[event]) return
    this.events[event].forEach((fn) => fn(...args))
  }

  off(event, fn) {
    if (!this.events[event]) return
    this.events[event] = this.events.filter((item) => item !== fn)
  }

  once(event, fn) {
    const that = this
    function onceFn(...args) {
      //执行一次
      fn.apply(that, args)
      //移除这个事件
      this.off(event, onceFn)
    }
    // 绑定事件
    this.on(event, onceFn)
  }
}
```

# 观察者模式

适用场景：

```js
class Subject {
  constructor(state) {
    this.state = state
    this.observers = []
  }
  //添加观察者
  attach(observer) {
    this.observers.push(observer)
  }
  //改变状态
  setState(state) {
    this.state = state
    this.notify()
  }
  //通知
  notify() {
    this.observers.forEach((observer) => observer.update(this))
  }
}

class Observer {
  //观察者:老师和家长
  constructor(name) {
    this.name = name
  }
  //更新事件
  update(sb) {
    console.log(`${this.name}收到${sb.name}的消息`)
  }
}

const student = new Subject("学生")
const teacher = new Observer("老师")
const parent = new Observer("家长")
student.attach(teacher)
student.attach(parent)
student.setState("生病")
//被观察者更新了状态之后要通知观察者，观察者查看状态
```

# 单例模式

1. 一个私有构造函数 （确保只能单例类自己创建实例）
2. 一个私有静态变量 （确保只有一个实例）
3. 一个公有静态函数 （给使用者提供调用方法）

适用场景

```js
class Singleton {
  constructor(name) {
    this.name = name
  }
  static getInstance(name) {
    if (!this.instance) {
      this.instance = new Singleton(name)
    }
    return this.instance
  }
}
let single1 = Single.getInstance("name1")
let single2 = Single.getInstance("name2")
console.log(single1 === single2) // true
```

# 实现 ajax

```js
function getQueryString(params) {
  let queryString = ""
  for (let key in params) {
    queryString += `${key}=${params[key]}&`
  }
  queryString = queryString.slice(0, -1)
  return queryString
}
function ajax(method, url, params, data) {
  return new Promise((resolve, reject) => {
    url = url + "?" + getQueryString(params)
    const xhr = new XMLHttpRequest()
    xhr.open(method, url, true)
    if (method.toLowerCase() === "get") {
      xhr.send()
    } else if (method.toLowerCase() === "post") {
      xhr.setRequestHeader("Content-Type", "application/json")
      xhr.send(JSON.stringify(data))
    }
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(xhr.responseText)
        } else {
          reject(xhr.status)
        }
      }
    }
  })
}
```

# 实现 jsonp

```js
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement("script")

    //回调函数接受数据
    window[callback] = function (data) {
      resolve(data)
      document.body.removeChild(script)
    }

    //拼接url
    url = url + "?" + getQueryString(params)
    script.src = url
    document.body.appendChild(script)
  })
}
// 测试
jsonp({
  url: "http://localhost:3000/api/user",
  params: { id: 1 },
  callback: "callback",
}).then((data) => {
  console.log(data)
})
```

# 实现 async 和 await

```js
const getData = () =>
  new Promise((resolve) => setTimeout(() => resolve("data"), 1000))

//// 生成器函数，generator生成器
function* read() {
  // await被编译成了yield
  const data = yield getData()
  console.log("data: ", data)
  const data2 = yield getData()
  console.log("data2: ", data2)
  return "success"
}

function asyncGenerator(gen) {
  return function () {
    const g = gen()
    return new Promise((resolve, reject) => {
      function next(key, arg) {
        let res = g[key](arg)
        const { value, done } = res
        if (done) {
          resolve(value)
        } else {
          // 如果value是promise，则递归调用next
          Promise.resolve(value).then((data) => next("next", data))
        }
      }
      next("next")
    })
  }
}

const reades = asyncGenerator(read)
reades().then((data) => {
  console.log(data)
})
```

# 实现迭代器生成函数

es6

```js
const arr = [1, 2, 3]
const len = arr.length
for (item of arr) {
  console.log(`当前元素是${item}`)
}

function* iteratorGenerator() {
  yield "1号选手"
  yield "2号选手"
  yield "3号选手"
}
```

es5

```js
function iteratorGenerator(list) {
  let index = 0
  return {
    next: function () {
      const done = index >= list.length
      const value = done ? undefined : list[index++]
      return {
        value,
        done,
      }
    },
  }
}
var iterator = iteratorGenerator(["1号选手", "2号选手", "3号选手"])
iterator.next()
iterator.next()
iterator.next()
```

# Object.create

```js
function create(obj) {
  const fn = function () {}
  fn.prototype = obj
  return new fn()
}
```

# Object.freeze

```js
function freeze(obj) {
  if (obj instanceof Object) {
    Object.seal(obj) //防止破坏对象的结构
    for (let key in obj) {
      if (obj.hasOwnPrototype(key)) {
        Object.definePrototype(obj, key, {
          writable: false,
          configurable: false,
          getter: function () {},
          setter: function (newValue) {},
        })
        freeze(obj[key])
      }
    }
  }
}
```

# Object.is

//===

```js
function is(x, y) {
  if (x === y) {
    //0 ，+0, -0
    return x !== 0 || 1 / x === 1 / y
  }
  //NaN，本身不等于本身
  return x !== x && y !== y
}

function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y
  }
  return x !== x && y !== y
}
```

# 实现 compose

```js
function compose(...fns) {
  if (!fns.length) return (...args) => args
  if (fns.length === 1) return fns[0]
  return fns.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args))
  )
}
//测试
const fn1 = (a) => a + 1
const fn2 = (a) => a + 2
const fn3 = (a) => a + 3
const fn = compose(fn1, fn2, fn3)
console.log(fn(1))
```

# setTimeout setInterval

使用 setTimeout 实现 setInterval

```js
function myInterval(fn, delay) {
  let timeId = null
  function interval() {
    //第一次调用
    fn()
    //递归调用
    timeId = setTimeout(() => {
      interval()
    }, delay)
  }
  timeId = setTimeout(() => {
    interval()
  }, delay)
  return {
    cancel: () => {
      clearTimeout(timeId)
    },
  }
}
```

```js
function mySetTimeout(fn, delay) {
  let timeId = null
  timeId = setInterval(() => {
    clearInterval(timeId)
    fn()
  }, delay)
}
```

# 框架

## react

### useState

```js
import React from "react";
import ReactDOM from "react-dom/client";

const rootElement = document.getElementById("root")!;
const root = ReactDOM.createRoot(rootElement);

let _state: any = [];
let index = 0;

const myUseState = (initialState: any) => {
  const currentIndex = index;
  _state[currentIndex] =
    _state[currentIndex] === undefined ? initialState : _state[currentIndex];

  const useState = (newValue: any) => {
    _state[currentIndex] = newValue;
    console.log("_state", _state);
    render();
  };

  index += 1;
  return [_state[currentIndex], useState];
};


function App() {
  const [num, setNum] = myUseState(0);
  const [num2, setNum2] = myUseState(0);

  return (
    <div className="App">
      <h1>Hello World</h1>
      <h2>{num}</h2>
      <button onClick={() => setNum(num + 1)}>点我加1</button>
      <h2>{num2}</h2>
      <button onClick={() => setNum2(num2 + 1)}>点我加1</button>
    </div>
  );
}

const render = () => {
  index = 0;
  root.render(<App />);
};

render();
```

## vue 数据双向绑定

## 虚拟 dom 转化为真实 dom

```js
{
  tag: 'DIV',
  attrs:{
  id:'app'
  },
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}

// 把上面虚拟Dom转化成下方真实Dom

<div id="app">
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>

function render(vNode){
  if(typeof vNode === 'number'){
    vNode = vNode.toString()
  }
  if(typeof vNode === 'string'){
    return document.createTextNode(vNode)
  }
  const {tag,attrs,children} = vNode
  const element = document.createElement(tag.toLowerCase())
  for(const key in attrs){
    if(attrs.hasOwnProperty(key)){
      element.setAttribute(key,attrs[key])
    }
  }
  //查看孩子是否为数组
  if(Array.isArray(children)){
    children.forEach(child=>element.appendChild(render(child)))
  }
  return element
}
```

# 实现模板字符串解析

```js
let template = "我是{{name}}，年龄{{age}}，性别{{sex}}"
let data = {
  name: "姓名",
  age: 18,
}
console.log(render(template, data)) // 我是姓名，年龄18，性别undefined

function render(template, data) {
  const reg = /\{\{(\w+)\}\}/g
  const result = template.replace(reg, (match, ket) => {
    return data[ket] === undefined ? "undefined" : data[ket]
  })
  return result
}
```

# 实现一下 hash 路由

```js
class HashRouter {
  constructor(routes) {
    this.routes = routes
    this.currentHash = ""
    this.refresh = this.refresh.bind(this)
    window.addEventListener("load", this.refresh, false)
    window.addEventListener("hashchange", this.refresh, false)
  }

  refresh() {
    this.currentHash = window.location.hash.slice(1) || "/"
    // 执行当前 hash 对应的回调函数
    this.routes[this.currentHash] && this.routes[this.currentHash]()
  }
}
// 使用
const router = new HashRouter({
  "/": () => console.log("home"),
  "/about": () => console.log("about"),
})
```

# 实现 history 路由

实现步骤
监听 URL 变化：

使用 popstate 事件监听浏览器前进/后退操作。

手动处理链接点击，阻止默认行为并使用 pushState 更新 URL。

更新 URL：

使用 pushState 添加新历史记录。

使用 replaceState 替换当前历史记录。

渲染对应组件：

根据 URL 变化，渲染相应的组件或内容。

```js
class HistoryRouter {
  constructor(routes) {
    this.routes = routes
    this.currentUrl = ""
  }

  //绑定事件
  bindEvent() {
    //浏览器的前进后退会触发
    window.addEventListener("popstate", this.popStateHandle.bind(this))

    //监听a标签的点击
    document.addEventListener("click", (e) => {
      const target = e.target
      if (target.tagName === "A") {
        e.preventDefault()
        this.push(null, "", target.href)
        this.routes[this.currentUrl] && this.routes[this.currentUrl]()
      }
    })
  }

  popStateHandle() {
    this.currentUrl = window.location.pathname || "/"
    this.routes[this.currentUrl] && this.routes[this.currentUrl]()
  }

  push(state, title, url) {
    history.pushState(state, title, url)
    this.currentUrl = url
    this.routes[this.currentUrl] && this.routes[this.currentUrl]()
  }

  //路由替换
  replace(state, title, path) {
    window.history.replaceState(state, title, path)
    this.currentUrl = path
    this.routes[this.currentUrl] && this.routes[this.currentUrl]()
  }

  //返回
  back() {
    window.history.back()
  }

  //go
  go(n) {
    window.history.go(n)
  }
}
```

# 数组

## forEach

```js
Array.prototype.myForEach = function (callback, context) {
  const self = this,
    len = self.length
  for (let i = 0; i < len; i++) {
    callback.call(context, self[i], i, self)
  }

  return self
}
```

## filter

```js
Array.prototype.myFilter = function (callback, context) {
  const self = this,
    len = self.length
  const newArr = []
  for (let i = 0; i < len; i++) {
    if (callback.call(context, self[i], i, self)) {
      newArr.push(self[i])
    }
  }
  return newArr
}
```

## map

```js
Array.prototype.myMap = function (callback, context) {
  const self = this,
    len = self.length
  const newArr = []
  for (let i = 0; i < len; i++) {
    newArr.push(callback.call(context, self[i], i, self))
  }
  return newArr
}
```

## find

```js
Array.prototype.myFind = function (callback) {
  const self = this,
    len = self.length
  for (let i = 0; i < len; i++) {
    if (callback(self[i], i)) {
      return self[i]
    }
  }
}
```

## findIndex

```js
Array.prototype.myFindIndex = function (callback) {
  const self = this,
    len = self.length
  for (let i = 0; i < len; i++) {
    if (callback(self[i], i)) {
      return i
    }
  }
}
```

## reduce

```js
Array.prototype.myReduce = function (callback, initValue) {
  const arr = this.slice(0)
  let res = initValue ? initValue : arr[0]
  const startIndex = initValue ? 0 : 1
  for (let i = startIndex; i < arr.length; i++) {
    res = callback.call(null, res, arr[i], i, this)
  }
  return res
}

//测试
const arr = [1, 2, 3, 4]
console.log(arr.myReduce((pre, cur) => pre + cur, 0))
```

## reduceRight

```js
Array.prototype.myReduceRight = function (callback, initValue) {
  const arr = this.slice(0)
  let res = initValue ? initValue : arr[arr.length - 1]
  const startIndex = initValue ? arr.length - 1 : arr.length - 2
  for (let i = startIndex; i >= 0; i--) {
    res = callback.call(null, res, arr[i], i, this)
  }
  return res
}
```

## every

```js
Array.prototype.myEvery = function (callback, context) {
  const len = this.length
  let flag = true
  for (let i = 0; i < len; i++) {
    if (!callback.call(context, this[i], i)) {
      flag = false
      break
    }
  }
  return flag
}
```

## some

```js
Array.prototype.mySome = function (callback, context) {
  const len = this.length
  let flag = false
  for (let i = 0; i < len; i++) {
    if (callback.call(context, this[i], i)) {
      flag = true
      break
    }
  }
  return flag
}
```

## 数组扁平化

//方法一 es6 flat

```js
const arr = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]
console.log(arr.flat(Infinity))
console.log(arr.flat(1))
```

//方法二 正则

```js
function flat(arr) {
  const reg = /\(\[|\]\)/g
  return arr
    .toString()
    .replace(reg, "")
    .split(",")
    .map((item) => Number(item))
}
```

//方法三 递归,根据深度

```js
function flat(arr, depth = 1) {
  if (depth === 0) return arr
  const res = []
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      res.push(...flat(item, depth - 1))
    } else {
      res.push(item)
    }
  })
  return res
}
```

//方法四，reduce,根据深度

```js
function flat(arr, depth = 1) {
  if (depth === 0) return arr
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur)
  }, [])
}
```

## Array.isArray

//方法一

```js
function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]"
}
```

//instanceof

```js
function isArray(obj) {
  return obj instanceof Array
}
```

//constructor

```js
function isArray(obj) {
  return obj.constructor === Array
}
```

## 检测类型

```js
function getType(value) {
  // 处理 null 的特殊情况
  if (value === null) {
    return "null"
  }

  // 处理基本类型
  if (typeof value !== "object") {
    return typeof value
  }

  // 处理引用类型
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}
```

## Array.of

```js
Array.prototype.myOf = function (...args) {
  return [...args]
}
Array.prototype.myOf = function (...args) {
  return [].slice.call(args)
}
```

## Array.from

```js
Array.myFrom = function (arrayLike, mapFn, thisArg) {
  // 1. 检查参数
  if (arrayLike == null) {
    throw new TypeError("Array.from requires an array-like object")
  }

  // 2. 将类数组转换为数组
  let items = Object(arrayLike)

  // 3. 获取长度
  const len = Number(items.length) || 0
  if (len <= 0) return []

  // 4. 创建新数组
  const result = new Array(len)

  // 5. 遍历并转换
  for (let i = 0; i < len; i++) {
    // 获取当前项
    let value = items[i]

    // 如果提供了映射函数，则使用映射函数处理
    if (mapFn) {
      result[i] = mapFn.call(thisArg, value, i, items)
    } else {
      result[i] = value
    }
  }

  return result
}
```

## 去重

//方法一 双层 for 循环

```js
function unique(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1)
        j--
        len--
      }
    }
  }
  return arr
}
```

//方法二 利用 Set

```js
function unique(arr) {
  return [...new Set(arr)]
}
```

//方法三 使用 map

```js
function unique(arr) {
  const map = new Map()
  return arr.filter((item) => {
    if (!map.has(item)) {
      map.set(item, true)
      return true
    }
    return false
  })
}
```

//方法四 使用 filter 和 indexOf

```js
function filter(arr) {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index
  })
}
```

//方法五 使用 reduce

```js
function unique(arr) {
  return arr.reduce((pre, curr) => {
    return pre.includes(curr) ? pre : [...pre, curr]
  }, [])
}
```

## 对象数组去重

```js
var resources = [
  { name: "张三", age: "18" },
  { name: "张三", age: "19" },
  { name: "张三", age: "20" },
  { name: "李四", age: "19" },
  { name: "王五", age: "20" },
  { name: "赵六", age: "21" },
]

//reduce + map
function unique(arr) {
  const temp = {}
  return arr.reduce((pre, curr) => {
    if (!temp[curr[name]]) {
      temp[curr[name]] = true
      pre.push(curr)
    }
    return pre
  }, [])
}

//使用reduce
function unique(arr, key) {
  return arr.reduce((pre, curr) => {
    const values = pre.map((item) => item[key])
    return values.includes(curr[key]) ? pre : [...pre, curr]
  }, [])
}
```

## 数组中的数据根据 key 去重

```js
function unique(arr, key = (item) => item) {
  const temp = {}
  return arr.reduce((pre, curr) => {
    if (!temp[key(curr)]) {
      temp[curr[key]] = true
      pre.push(curr)
    }
    return pre
  }, [])
}

const dedup = (data, getKey = () => {}) => {
  const dateMap = data.reduce((pre, cur) => {
    const key = getKey(cur)
    if (!pre[key]) {
      pre[key] = cur
    }
    return pre
  }, {})
  return Object.values(dateMap)
}
```

## 类数组转化为数组

```js
// 1.扩展运算符
;[...arrayLike]
// 2.Array.from
Array.from(arrayLike)
// 3.Array.prototype.slice
Array.prototype.slice.call(arrayLike)
// 4.Array.apply
Array.apply(null, arrayLike)
// 5.Array.prototype.concat
Array.prototype.concat.apply([], arrayLike)
```

## 字符串中字母出现的次数

```js
const str = "sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha"

const res = str.split("").reduce((pre, next) => {
  pre[next] ? pre[next]++ : (pre[next] = 1)
  return pre
}, {})
```

# 实现千位符

//方法一

```js
function thousandSeparator(num) {
  const arr = num.toString().split(".")
  const decimal = arr[1]
  let integer = arr[0]
  let newNum = []
  integer = integer.split("")
  integer.reverse()
  for (let i = 0; i < integer.length; i++) {
    if (i % 3 === 0 && i !== 0) {
      newNum.push(",")
    }
    newNum.push(integer[i])
  }
  newNum = newNum.reverse().join("")
  if (decimal) {
    newNum += `.${decimal}`
  }
  return newNum
}
console.log(thousandSeparator(123456789.123))
```

//方法二正则表达式

```js
unction formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
}

```

//方法三

```js
function thousandSeparator(num) {
  return num.toLocaleString()
}

console.log(thousandSeparator(123456789))
```

## 正则匹配手机号

```js
function isPhone(phone) {
  return /^1[3-9]\d{9}$/.test(phone)
}
```

## 正则匹配邮箱

\w 表示字母、数字、下划线

```js
function isEmail(email) {
  return /^[\w-]+\@[\w]+\.[\w]+$/.test(email)
}
```

## 身份证

```js
function isIdCard(idCard) {
  return /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[1-2]\d|3[0-1])\d{3}(\d|X)$/.test(
    idCard
  )
}
```

## 用正则写一个根据 name 获取 cookie 中的值的方法

```js
function getCookie(name) {
  const cookie = document.cookie
  const reg = new RegExp(`(^| )${name}=([^;]*)(;|$)`)
  const arr = cookie.match(reg)
  return arr ? arr[2] : null
}
```

# hotkeys 实现原理

```js
class HotkeyManager {
  constructor() {
    this.hotkeys = {}
    this.registerEvents()
  }

  registerEvents() {
    document.addEventListener("keydown", this.handleKeydown.bind(this))
  }

  register(keyCombination, callback) {
    this.hotkeys[keyCombination] = callback
  }

  unregister(keyCombination) {
    delete this.hotkeys[keyCombination]
  }

  handleKeydown(event) {
    const keys = []
    if (event.ctrlKey) keys.push("Control")
    if (event.shiftKey) keys.push("Shift")
    if (event.altKey) keys.push("Alt")
    if (event.metaKey) keys.push("Meta") // Windows 键或 Command 键
    keys.push(event.key)

    const combination = keys.join("+")

    if (this.hotkeys[combination]) {
      this.hotkeys[combination]()
      event.preventDefault() // 阻止默认行为
    }
  }
}

const hotkeyManager = new HotkeyManager()

// 注册快捷键
hotkeyManager.register("Control+c", () => {
  console.log("Ctrl+C 被按下")
})

hotkeyManager.register("Shift+F", () => {
  console.log("Shift+F 被按下")
})

hotkeyManager.register("Alt+s", () => {
  console.log("Alt+S 被按下")
})

hotkeyManager.register("Meta+z", () => {
  console.log("Command/Windows+Z 被按下")
})
```

# 柯里化

柯里化(Currying)是一种将多参数函数转换为一系列单参数函数的技术。主要作用是参数复用和延迟执行。

使用场景：数据校验、api 封装

```js
// 基础柯里化函数
const curry = (fn) => {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return (...args2) => curried.apply(this, [...args, ...args2])
  }
}

// 示例：数据校验
const validate = curry((regex, errorMsg, value) => {
  if (!regex.test(value)) {
    return errorMsg
  }
  return true
})

// 创建特定的验证器
const validateEmail = validate(/^[\w-]+@[\w]+\.[\w]+$/, "无效的邮箱地址")
const validatePhone = validate(/^1[3-9]\d{9}$/, "无效的手机号码")

// 使用
console.log(validateEmail("test@example.com")) // true
console.log(validatePhone("12345678901")) // true

//api复用
const request = curry((baseURL, path, params) => {
  return fetch(`${baseURL}${path}`, params)
})

// 创建特定域名的请求
const requestWithBase = request("https://api.example.com")

// 进一步创建特定路径的请求
const getUserInfo = requestWithBase("/user/info")
const getOrderList = requestWithBase("/order/list")

// 使用
getUserInfo({ userId: 1 })
getOrderList({ page: 1 })
```

## 实现 curry

```js
function curry(fn) {
  const length = fn.length
  return function calc(...args2) {
    if (args2.length >= length) {
      return fn(...args2)
    }
    return (...args3) => calc(...args2, ...args3)
  }
}

//ES6写法
const curry2 =
  (fn, arr = []) =>
  (...args) =>
    [...arr, ...args].length >= fn.length
      ? fn(...[...arr, ...args])
      : curry2(fn, [...arr, ...args])

let _fn = curry(function (a, b, c, d, e) {
  console.log(a, b, c, d, e)
})
_fn(1, 2, 3, 4, 5) // print: 1,2,3,4,5
_fn(1)(2)(3, 4, 5) // print: 1,2,3,4,5
_fn(1, 2)(3, 4)(5) // print: 1,2,3,4,5
_fn(1)(2)(3)(4)(5) // print: 1,2,3,4,5
```

## 实现 add

```js
add(1); 			// 1
add(1)(2);  	// 3
add(1)(2)(3)；// 6
add(1)(2, 3); // 6
add(1, 2)(3); // 6
add(1, 2, 3); // 6

function add(...args) {
  const fn = (...args1) => {
    return add.apply(null, [...args, ...args1])
  }
  fn.toString = () => {
    return args.reduce((a, b) => a + b, 0)
  }
  return fn
}
console.log(add(1)(2).toString())

```

## 实现 (5).add(3).minus(2) 功能

```js
// ;(4).add(3).minus(2)

Number.prototype.add = function (num) {
  return this + num
}

Number.prototype.minus = function (num) {
  return this - num
}

console.log((4).add(3).minus(2))
```

## 实现 add(1)(2)

```js
function add(x) {
  let sum = x
  function temp(y) {
    sum += y
    return temp
  }
  temp.toString = () => {
    return sum
  }
  return temp
}

console.log(add(1)(2).toString())
```

# 字符串

## 查找字符串中出现最多的字符和个数

```js
//例: abbcccddddd -> 字符最多的是d，出现了5次
function findMaxChar(str) {
  let map = {}
  for (let i = 0; i < str.length; i++) {
    if (map[str[i]]) {
      map[str[i]]++
    } else {
      map[str[i]] = 1
    }
  }
  let maxChar = ""
  let maxCount = 0
  for (let key in map) {
    if (map[key] > maxCount) {
      maxCount = map[key]
      maxChar = key
    }
  }
  return {
    maxChar,
    maxCount,
  }
}
```

## 字符串查找

<!-- 请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。 -->

```js
a = "34"
b = "1234567" // 返回 2
a = "35"
b = "1234567" // 返回 -1
a = "355"
b = "12354355" // 返回 5
isContain(a, b)
function isContain(a, b) {
  for (let i = 0; i < b.length; i++) {
    if (b.slice(i, i + a.length) === a) {
      return i
    }
  }
  return -1
}

console.log(isContain(a, b))
```

## 字符串最长的不重复子串

```js
function lengthOfLongestSubstring(s) {
  let map = {}
  let left = 0
  let right = 0
  let maxCount = 0
  while (right < s.length) {
    if (!map[s[right]]) {
      map[s[right]] = 1
      right++
    } else {
      while (s[left] !== s[right]) {
        map[s[left]]--
        left++
      }
      left++
      right++
    }
    maxCount = Math.max(maxCount, right - left)
  }
  return maxCount
}

console.log(lengthOfLongestSubstring("abcabcbb"))
```

# serviceWork

Service Worker 是浏览器在后台独立于网页运行的、用 JavaScript 编写的脚本。

我们需要手动编写 service-worker.js 文件。
我们需要在网页中下载并注册 service-worker.js 文件。
Service Worker 具有超能力，可以拦截并处理 HTTP 请求。

场景：

- 离线访问
- 缓存资源
- 拦截请求

```js
const CACHE_NAME = "v1"
const OFFLINE_ASSETS = [
  "/offline.html",
  "/styles/offline.css",
  "/images/offline.png",
  "/scripts/offline-game.js",
]
if (navigator.serviceWorker) {
  navigator.serviceWorker.register("service-worker.js")then((registration) => {}).catch((error) => {})
}

// 安装
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      // 预缓存离线资源
      return cache.addAll(OFFLINE_ASSETS)
    })
  )
})

// 激活
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      )
    })
  )
})

// 请求拦截
self.addEventListener("fetch", (event) => {
  event.respondWith(
    // 尝试网络请求
    fetch(event.request).catch(() => {
      // 根据请求类型返回不同的离线响应
      if (event.request.mode === "navigate") {
        return caches.match("/offline.html")
      }

      // 其他资源尝试从缓存获取
      return caches.match(event.request)
    })
  )
})
```

# Js 工具函数

## 对象扁平化

```js
function flatObj(obj) {
  let res = {}
  function flat(obj, preKey = "") {
    Object.entries(obj).forEach(([key, value]) => {
      let newKey = preKey ? `${preKey}.${key}` : key
      if (typeof value === "object" && value !== null) {
        flat(value, newKey)
      } else {
        res[newKey] = value
      }
    })
  }
  flat(obj)
  return res
}

// 测试
const source = { a: { b: { c: 1, d: 2 }, e: 3 }, f: { g: 2 } }
console.log(flatObj(source))

//对象扁平化
function flatObj(obj) {
  const res = {}
  function flat(obj, preKey = "") {
    Object.entries(obj).forEach(([key, value]) => {
      const newKey = preKey ? `${preKey}.${key}` : key
      if (typeof value !== "object" && value !== null) {
        res[newKey] = value
      } else if (Array.isArray(value)) {
        value.forEach((item, index) => {
          if (typeof item === "object" && value !== null) {
            flat(item, `${newKey}[${index}]`)
          } else {
            res[`${newKey}[${index}]`] = item
          }
        })
      } else if (typeof value === "object" && value !== null) {
        flat(value, newKey)
      }
    })
  }
  flat(obj)
  return res
}

console.log(
  flatObj({ a: { b: { c: 1, d: 2 }, e: 3 }, f: { g: 2, e: [1, 2, { a: 1 }] } })
)
```

##实现一个管理本地缓存过期的函数

```js
function Storage{
  constructor(name){
    this.name = name
  }
  setItem(params){
    let options = {
      key:'',
      value:'',
      expire:'',
      startTime: new Date().getTime(),
    }
    Object.assign(options, params)
    if (options.expire) {
      localStorage.setItem(options.key, JSON.stringify(options))
    } else {
      localStorage.setItem(options.key, JSON.stringify(options.value))
    }
  }
  getItem(key){
    let item = localStorage.getItem(key)
    if (!item) return null
    let { value, startTime, expire } = JSON.parse(item)
    // 判断是否过期
    if (expire && new Date().getTime() - startTime > expire) {
      this.removeItem(key)
      return null
    }
    return value
  }
  removeItem(key) {
    localStorage.removeItem(key)
  }
  clear() {
    localStorage.clear()
  }
}
```

## 实现 lodash 的 chunk 方法--数组按指定长度拆分

```js
function chunk(arr, size) {
  const newArr = []
  for (let i = 0; i < arr.length; i += size) {
    newArr.push(arr.slice(i, i + size))
  }
  return newArr
}

console.log(chunk([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3))
```

## 写一个倒计时组件

```vue
<template>
  <div class="countdown">
    {{ formattedTime }}
  </div>
</template>

<script>
import { ref, computed, onMounted, onUnmounted } from "vue"

export default {
  props: {
    seconds: {
      type: Number,
      required: true,
      validator: (value) => value >= 0, // 确保秒数为非负数
    },
  },
  setup(props) {
    const remainingSeconds = ref(props.seconds) // 剩余秒数
    let timer = null // 定时器

    // 格式化时间为 hh:mm:ss
    const formattedTime = computed(() => {
      const hours = Math.floor(remainingSeconds.value / 3600)
      const minutes = Math.floor((remainingSeconds.value % 3600) / 60)
      const seconds = remainingSeconds.value % 60

      // 补零操作
      const pad = (num) => String(num).padStart(2, "0")

      return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`
    })

    // 开始倒计时
    const startCountdown = () => {
      timer = setInterval(() => {
        if (remainingSeconds.value > 0) {
          remainingSeconds.value--
        } else {
          clearInterval(timer) // 倒计时结束，清除定时器
        }
      }, 1000)
    }

    // 组件挂载时启动倒计时
    onMounted(() => {
      startCountdown()
    })

    // 组件卸载时清除定时器
    onUnmounted(() => {
      if (timer) {
        clearInterval(timer)
      }
    })

    return {
      formattedTime,
    }
  },
}
</script>

<style scoped>
.countdown {
  font-family: Arial, sans-serif;
  font-size: 2rem;
  color: #333;
  text-align: center;
  padding: 20px;
  background-color: #f0f0f0;
  border-radius: 8px;
  display: inline-block;
}
</style>
```

## 手写实现深度 isEqual

```js
const isObject = (obj) => typeof obj === "object" && obj !== null
function isEqual(obj1, obj2) {
  //不是对象
  if (!isObject(obj1) || !isObject(obj2)) {
    return obj1 === obj2
  }
  //判断是否为一个变量
  if (obj1 === obj2) {
    return true
  }
  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)
  if (keys1.length !== keys2.length) {
    return false
  }
  for (let key in obj1) {
    if (
      Object.hasOwnProperty.call(obj1, key) &&
      Object.hasOwnProperty.call(obj2, key)
    ) {
      //递归
      if (!isEqual(obj1[key], obj2[key])) {
        return false
      }
    }
  }
  return true
}
;("")

//测试
const obj1 = { a: 1, b: { c: 2, d: 3 }, e: 123 }
const obj2 = { a: 1, b: { c: 2, d: 3 } }
console.log(isEqual(obj1, obj2))
```

## 实现 json.stringify

```js
const isObject = (obj) => typeof obj === "object" && obj !== null
function stringify(obj, seen = new WeakSet()) {
  //判断obj
  if (!isObject(obj)) {
    //判断是否为null
    if (obj === null) {
      return "null"
    }
    //判断是否为bigInt
    if (typeof obj === "bigint") {
      throw new Error("BigInt value cannot be serialized")
    }
    if (
      typeof obj === "undefined" ||
      typeof obj === "function" ||
      typeof obj === "symbol"
    ) {
      //判断是否为undefined、function、symbol
      return undefined
    }
    //判断是否为number、boolean
    if (typeof obj === "number" || typeof obj === "boolean") {
      return obj + ""
    }
    //判断是否为string
    if (typeof obj === "string") {
      return `"${obj}"`
    }
    return obj
  } else {
    //判断数组
    if (Array.isArray(obj)) {
      if (seen.has(obj)) {
        throw new Error("Circular reference detected")
      }
      seen.add(obj)
      let result = []
      obj.forEach((item, index) => {
        //判断是否为function、symbol、undefined
        if (
          typeof item === "function" ||
          typeof item === "symbol" ||
          typeof item === "undefined"
        ) {
          result[index] = undefined
        } else {
          result[index] = stringify(item, seen)
        }
      })

      //返回
      return `[${result.join(",")}]`
    } else {
      //解决循环依赖
      if (seen.has(obj)) {
        throw new Error("Circular reference detected")
      }
      seen.add(obj)
      // 判断是否为toJson
      if (typeof obj === "object" && typeof obj.toJSON === "function") {
        return obj.toJSON()
      }
      let result = {}
      Object.keys(obj).forEach((key) => {
        result[key] = stringify(obj[key], seen)
      })
      return `{${Object.keys(result)
        .map((key) => `${key}:${result[key]}`)
        .join(",")}}`
    }
  }
}

//测试循环依赖
const obj = { a: 1, b: 2, c: 3 }
obj.a = obj
console.log(stringify(obj))
```

## 实现 json.parse

```js
function parse(str) {
  if (str === "") {
    throw new Error()
  }
  if (str[0] === "'") {
    throw new Error()
  }

  if (str === "[]") {
    return []
  }
  if (str === "{}") {
    return {}
  }
  if (str === "null") {
    return null
  }
  if (str === "undefined") {
    return undefined
  }

  if (str === "true") {
    return true
  }
  if (str === "false") {
    return false
  }
  if (str[0] === '"') {
    return str.slice(1, -1)
  }
  if (+str === +str) {
    return Number(str)
  }
  //数组
  if (str[0] === "[") {
    return str
      .slice(1, -1)
      .split(",")
      .map((value) => parse(value))
  }

  //对象
  if (str[0] === "{") {
    return str
      .slice(1, -1)
      .split(",")
      .reduce((pre, cur) => {
        const arr = cur.split(":")
        const key = arr[0]
        const value = arr[1]
        pre[parse(key)] = parse(value)
        return pre
      }, {})
  }
}
```

## 解析 URL Params 为对象

```js
let url =
  "http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled"
console.log(parseParam(url))

function parseParam(url) {
  const params = {}
  const index = url.indexOf("?")
  if (index === -1) {
    return params
  }
  const str = url.slice(index + 1)
  //进行切分
  const arr = str.split("&")
  arr.forEach((item) => {
    const [key, value] = item.split("=")
    if (!value) {
      params[decodeURIComponent(key)] = true
    } else {
      if (params[decodeURIComponent(key)]) {
        const array =
          params[decodeURIComponent(key)] instanceof Array
            ? params[decodeURIComponent(key)]
            : [params[decodeURIComponent(key)]]
        params[decodeURIComponent(key)] = [...array, decodeURIComponent(value)]
      } else {
        params[decodeURIComponent(key)] = decodeURIComponent(value)
      }
    }
  })
  return params
}
```

## 转化为驼峰命名

```js
//转化为驼峰命名  user-name => userName
function toHump(str) {
  const reg = /-\w/g
  return str.replace(reg, (match) => {
    return match.slice(1).toUpperCase()
  })
}

console.log(toHump("user-name"))

//转化为下划线  userName => user-name
function toLine(str) {
  const reg = /[A-Z]/g
  return str.replace(reg, (match, offset) => {
    // 如果是第一个大写字母，不加连字符
    if (offset === 0) {
      return match.toLowerCase()
    }
    return "-" + match.toLowerCase()
  })
}

console.log(toLine("userName"))
```

## 实现一个函数判断数据类型

```js
function getType(obj) {
  if (obj === null) return obj + ""
  const type =
    typeof obj === "object"
      ? Object.prototype.toString.call(obj).slice(8, -1)
      : typeof obj
  return type
}

console.log(getType(null))
console.log(getType(undefined))
console.log(getType(123))
console.log(getType("123"))
console.log(getType(true))
console.log(getType({}))
console.log(getType([]))
console.log(getType(() => {}))
```

## 对象数组列表转成树形结构（处理菜单）

```js
// 对象数组列表转成树形结构
function listToTree(list) {
  const result = []
  const map = {}
  list.forEach((item) => {
    map[item.id] = item
  })
  for (let i = 0; i < list.length; i++) {
    if (map[list[i].pid]) {
      if (!map[list[i].pid].children) {
        map[list[i].pid].children = []
      }
      map[list[i].pid].children.push(list[i])
    } else {
      result.push(list[i])
    }
  }
  return result
}

function listToTree(list) {}

//测试
const list = [
  { id: 1, name: "部门1", pid: 0 },
  { id: 2, name: "部门2", pid: 1 },
  { id: 3, name: "部门3", pid: 1 },
  { id: 4, name: "部门4", pid: 3 },
  { id: 5, name: "部门5", pid: 4 },
]
console.log(listToTree(list))
```

## 树形结构转成列表（处理菜单）

```js
//树形结构转成列表
function treeToList(tree) {
  const result = []
  function dfs(tree) {
    const len = tree.length
    for (let i = 0; i < len; i++) {
      const list = tree[i]
      if (list.children) {
        dfs(list.children)
        delete list.children
      }
      result.push(list)
    }
  }
  dfs(tree)
  return result
}

//测试
const tree = [
  {
    id: 1,
    name: "部门1",
    pid: 0,
    children: [{ id: 2, name: "部门2", pid: 1 }],
  },
  {
    id: 3,
    name: "部门3",
    pid: 1,
    children: [{ id: 4, name: "部门4", pid: 3 }],
  },
  {
    id: 5,
    name: "部门5",
    pid: 4,
    children: [{ id: 6, name: "部门6", pid: 5 }],
  },
]
console.log(treeToList(tree))
```

# Promise 实现加载图片

```js
function loadImg(url) {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.src = url
    img.onerror = () => {}
    img.onload = () => {
      resolve(img)
    }
  })
}
// 测试
loadImg(
  "https://img.alicdn.com/imgextra/i2/O1CN01KqzcY21rXQ1XKRZYG_!!6000000000085-0-tps-200-200.png"
).then((res) => {
  console.log(img)
})
```

# 请求接口并发控制数量

```js
function concurRequest(urls, maxNum) {
  return new Promise((resolve, reject) => {
    if (urls.length === 0) {
      resolve([])
      return
    }
    let result = []
    let index = 0
    let count = 0 //当前请求的完成数量
    //发请求
    async function request() {
      if (urls.length === index) return
      const i = index
      const url = urls[index]
      index++
      try {
        const res = await fetch(url)
        result[i] = res
      } catch (err) {
        result[i] = error
      } finally {
        count++
        if (count === urls.length) {
          resolve(result)
        }
        request()
      }
    }
    //调用请求
    const time = Math.min(maxNum, urls.length)
    for (let i = 0; i < time; i++) {
      request()
    }
  })
}
```

```js
function concurRequest(urls, maxNum = 3, maxRetry = 3) {
  const list = [...urls]
  const failUrl = []
  const result = []
  let activeUploaded = 0
  let retryCount = 0

  const request = async (url) => {
    try {
      const res = await fetch(url)
      result.push(res)
    } catch (err) {
      failUrl.push(url)
    } finally {
      activeUploaded--
      if (list.length) {
        request(list.shift())
      }
    }
  }

  //重试
  const retry = () => {
    while (failUrl.length > 0 && retryCount < maxRetry) {
      retryCount++
      list = [...failUrl]
      failUrl = []
      processQueue()
    }
    //如果重试次数超过最大次数，则返回错误
    if (retryCount >= maxRetry) {
      //TODO: 提示
      alert("重试次数超过最大次数")
    }
  }

  const processQueue = async () => {
    while (list.length && activeUploaded < maxNum) {
      const url = list.shift()
      activeUploaded++
      request(url)
      if (list.length === 0 && activeUploaded === 0) {
        retry()
      }
    }
  }

  processQueue()
}

const promiseLimitByCycle = async <T>(
  arr: T[],
  limit: number,
  iteratorFn: (item: T, arr?: T[]) => Promise<any>
) => {
  const { length } = arr
  const result: Promise<any>[] = []
  const runningList: Promise<any>[] = [] // 正在执行的异步任务

  for (const url of arr) {
    const p = Promise.resolve().then(iteratorFn(url)) // 转为promise
    result.push(p)

    // 若limit大于length，则不再进行控制，直接用Promise.all()即可
    if (limit <= length) {
      const e = p.then(() => {
        // promise p 执行完毕时，会触发这个，这个是后执行的，先执行的是下面的push操作
        const index = runningList.indexOf(e)
        // 当p执行成功的时候，从runningList中删除该Promise，同时也会触发下面的Promise.race()
        return runningList.splice(index, 1)
      })
      // promise e 是 p执行的过程，若p执行成功，则e.value就是p.then()里的return的值
      runningList.push(e)

      // 超过限制，则先存储起来
      if (runningList.length >= limit) {
        // 哪个先完成，都会触发race，然后进入下一层循环
        await Promise.race(runningList)
      }
    }
  }
  // 所有的都完成了，才最后返回结果
  return Promise.all(result)
}
```

# useClickOutside

```js
// composables/useClickOutside.ts
import { onMounted, onUnmounted, ref, type Ref } from 'vue'

export function useClickOutside(elementRef: Ref<HTMLElement | null>) {
  const isClickOutside = ref(false)

  const handler = (e: MouseEvent) => {
    if (elementRef.value) {
      // 判断点击事件是否发生在元素外部
      isClickOutside.value = !elementRef.value.contains(e.target as Node)
    }
  }

  onMounted(() => {
    document.addEventListener('click', handler)
  })

  onUnmounted(() => {
    document.removeEventListener('click', handler)
  })

  return {
    isClickOutside
  }
}

import { useEffect, useRef } from "react"
function useClickOutside(callback) {
  const ref = useRef(null)

  useEffect(() => {
    const handleClick = (e) => {
      if (ref.current && !ref.current.contains(e.target)) {
        callback()
      }
    }

    window.addEventListener("click", handleClick)
    return () => {
      window.removeEventListener("click", handleClick)
    }
  }, [])
  return ref
}

// App component
export function App() {
  const [isOpen, setIsOpen] = useState(false)
  const closeModal = () => setIsOpen(false)
  const ref = useClickOutside < HTMLDivElement > closeModal

  const openModal = () => {
    setIsOpen(true)
  }

  return (
    <div>
      <button onClick={openModal}>Open Modal</button>
      {isOpen && (
        <div
          ref={ref}
          style={{
            position: "absolute",
            backgroundColor: "white",
            border: "1px solid black",
            padding: "20px",
          }}
        >
          <p>This is a modal. Click outside to close it.</p>
        </div>
      )}
    </div>
  )
}

// Rendering the App component
ReactDOM.render(<App />, document.getElementById("root"))
```

# useLoadMore

```js
import { useEffect, useMemo, useRef, useState } from 'react'
import { useAppDispatch } from '../stores'

interface IParams {
    pageIndex: number
    pageSize: number
    [key: string]: string | number
}

export const useLoadMore = (
    api: (params: any) => void,
    total: number,
    params: IParams,
) => {
    const dispatch = useAppDispatch()
    const [pageIndex, setPageIndex] = useState(
        (params && params.pageIndex) || 0,
    )

    const requestParam = useMemo(() => {
        return {
            ...params,
            pageIndex: pageIndex,
        }
    }, [params, pageIndex])

    //加载更多
    const loadMore = () => {
        setPageIndex(pageIndex + 1)
    }

    const gotoPage = (page: number) => {
        setPageIndex(page)
    }

    useEffect(() => {
        dispatch(api(requestParam) as any)
    }, [pageIndex])

    //是否为最后一页
    const isLastPage = useMemo(() => {
        return Math.ceil(total / params.pageSize) === pageIndex + 1
    }, [total, params.pageSize, pageIndex])

    return {
        loadMore,
        pageIndex,
        isLastPage,
        gotoPage,
    }
}


```

# 实现字符串的 trim

```js
function trim(str) {
  return str.replace(/^\s+|\s+$/g, "")
}

console.log(trim("  hello  "))
```

# 判断元素是否在可视区域

````js
//方法一
function isContain(dom) {
  // 获取可视窗口的盖度。
  const screenHeight =
    window.innerHeight ||
    document.documentElement.clientHeight ||
    document.body.clientHeight

  // 获取滚动条滚动的高度
  const scrollTop = document.documentElement.scrollTop
  // 获取元素偏移的高度。就是距离可视窗口的偏移量。
  const offsetTop = dom.offsetTop
  console.log(screenHeight, offsetTop, scrollTop)
  return offsetTop - scrollTop <= screenHeight
}


//方法二
const observer = new IntersectionObserver(
  (entries) => {
    if (entries[0].isIntersecting) {
      document.body.style.backgroundColor = "blue"
    } else {
      document.body.style.backgroundColor = "green"
    }
  },
  { threshold: 0.2 }
)
const p = document.getElementById("p")
observer.observe(p)



# 实现拖拽

```js

````

# EditInput 组件编写

```

```

# 虚拟列表

```js
//虚拟列表实现高度定高
import React, { useState } from "react"

const VirtualList = (props) => {
  const { height, width, children: Child, itemHeight, itemCount } = props
  const containerStyle = {
    position: "relative",
    height,
    width,
    overflow: "auto",
  }
  const contentStyle = {
    position: "absolute",
    top: 0,
    left: 0,
    height: itemHeight * itemCount,
    width: "100%",
  }
  const [scrollHeight, setScrollHeight] = useState(0)

  const getCurrentChildren = () => {
    const count = Math.floor(height / itemHeight)
    const viewStart = Math.floor(scrollHeight / itemHeight)
    const TopStart = Math.max(0, viewStart - 2)
    const bottomEnd = Math.min(itemCount, viewStart + count + 2)
    const children = []
    for (let i = TopStart; i < bottomEnd; i++) {
      const childStyle = {
        height: itemHeight,
        width: "100%",
        position: "absolute",
        top: i * itemHeight,
      }
      children.push(<Child key={i} style={childStyle}></Child>)
    }
    console.log(bottomEnd, viewStart, count)
    return children
  }

  const handleScroll = (event) => {
    setScrollHeight(event.target.scrollTop)
  }

  return (
    <div style={containerStyle} onScroll={handleScroll}>
      <div style={contentStyle}>{getCurrentChildren()}</div>
    </div>
  )
}

export default VirtualList
```

```js
//虚拟列表实现高度不定
```

# 实现 sleep

```js
function sleep(time) {
  return new Promise((resolve) => setTimeout(resolve, time))
}
sleep(1000).then(() => {
  // 这里写你的骚操作
})
```

# 给定两个数组，写一个方法来计算它们的交集

例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

```js
function intersection(nums1, nums2) {
  return nums1.filter((item) => nums2.includes(item))
}

qconsole.log(intersection([1, 2, 2, 1], [2, 2]))
```

# 异步串行 | 异步并行

```js
// 字节面试题，实现一个异步加法
function asyncAdd(a, b, callback) {
  setTimeout(function () {
    callback(null, a + b)
  }, 500)
}

function promisify(a, b) {
  return new Promise((resolve, reject) => {
    asyncAdd(a, b, (err, res) => {
      if (err) {
        reject(err)
      } else {
        resolve(res)
      }
    })
  })
}

//串行异步
function serialAdd(...args) {
  return args.reduce(
    (pre, now) => pre.then((res) => promisify(res, now)),
    Promise.resolve(0)
  )
}

async function serialAdd(...args) {
  let result = 0
  for (let num of args) {
    result = await promisify(result, num)
  }
  return result
}

serialAdd(1, 2, 3, 4, 5).then((res) => {
  console.log(res)
})

//并行异步
async function parallelSum(...args) {
  if (args.length === 1) return args[0]
  const tasks = []
  for (let i = 0; i < args.length; i += 2) {
    tasks.push(promisify(args[i], args[i + 1] || 0))
  }
  const results = await Promise.all(tasks)
  return parallelSum(results)
}

parallelSum(1, 2, 3, 4, 5).then((res) => {})

function promiseAdd(fn) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, res) => {
        if (err) {
          reject(err)
        } else {
          resolve(res)
        }
      })
    })
  }
}
promiseAdd(asyncAdd)(1, 2).then((res) => {
  console.log(res)
})
```

# 图片懒加载

```js
function isVisible(el) {
  const scrollTop = document.documentElement.scrollTop
  const elTop = el.offsetTop
  const windowHeight = document.documentElement.clientHeight
  return elTop - scrollTop <= windowHeight
}
function imageLazy() {
  const images = document.querySelectorAll("img")
  for (let img of images) {
    const src = img.dataset.src
    //查看是否在可视区域
    if (isVisible(img)) {
      img.src = src
      img.dataset.src = ""
    }
  }
}

// 测试
window.addEventListener("load", imageLazyLoad)
window.addEventListener("scroll", imageLazyLoad)
// or
window.addEventListener("scroll", throttle(imageLazyLoad, 1000))
```

# 滚动加载

```js
window.addEventListener(
  "scroll",
  function () {
    const clientHeight = document.documentElement.clientHeight
    const scrollTop = document.documentElement.scrollTop
    const scrollHeight = document.documentElement.scrollHeight
    if (clientHeight + scrollTop >= scrollHeight) {
      // 检测到滚动至页面底部，进行后续操作
      // ...
    }
  },
  false
)
```

# 渲染几万条数据不卡顿

```js
setTimeout(() => {
  // 插入十万条数据
  const total = 100000
  // 一次插入的数据
  const once = 20
  // 插入数据需要的次数
  const loopCount = Math.ceil(total / once)
  let countOfRender = 0
  const ul = document.querySelector("ul")
  // 添加数据的方法
  function add() {
    const fragment = document.createDocumentFragment()
    for (let i = 0; i < once; i++) {
      const li = document.createElement("li")
      li.innerText = Math.floor(Math.random() * total)
      fragment.appendChild(li)
    }
    ul.appendChild(fragment)
    countOfRender += 1
    loop()
  }
  function loop() {
    if (countOfRender < loopCount) {
      window.requestAnimationFrame(add)
    }
  }
  loop()
}, 0)
```

# 打印出当前网页使用了多少种 HTML 元素

```js
const fn = () => {
  return [
    ...new Set([...document.querySelectorAll("*")].map((el) => el.tagName)),
  ].length
}
```

# 限制次数重试

```js
function retry(fn, times) {
  return new Promise((resolve, reject) => {
    const attempt = (time) => {
      fn()
        .then(resolve)
        .catch((err) => {
          if (times === 0) {
            reject(err)
          } else {
            attempt(time - 1)
          }
        })
    }
    attempt(times)
  })
}
```

# 实现 getter 和 setter

```js
// 示例
var object = { a: [{ b: { c: 3 } }] } // path: 'a[0].b.c'
var array = [{ a: { b: [1] } }] // path: '[0].a.b[0]'

function getValue(target, valuePath, defaultValue) {}

console.log(getValue(object, "a[0].b.c", 0)) // 输出3
console.log(getValue(array, "[0].a.b[0]", 12)) // 输出 1
console.log(getValue(array, "[0].a.b[0].c", 12)) // 输出 12

/**
 * 测试属性是否匹配
 */
export function testPropTypes(value, type, dev) {
  const sEnums = ["number", "string", "boolean", "undefined", "function"] // NaN
  const oEnums = ["Null", "Object", "Array", "Date", "RegExp", "Error"]
  const nEnums = [
    "[object Number]",
    "[object String]",
    "[object Boolean]",
    "[object Undefined]",
    "[object Function]",
    "[object Null]",
    "[object Object]",
    "[object Array]",
    "[object Date]",
    "[object RegExp]",
    "[object Error]",
  ]
  const reg = new RegExp("\\[object (.*?)\\]")

  // 完全匹配模式，type应该传递类似格式[object Window] [object HTMLDocument] ...
  if (reg.test(type)) {
    // 排除nEnums的12种
    if (~nEnums.indexOf(type)) {
      if (dev === true) {
        console.warn(
          value,
          "The parameter type belongs to one of 12 types：number string boolean undefined Null Object Array Date RegExp function Error NaN"
        )
      }
    }

    if (Object.prototype.toString.call(value) === type) {
      return true
    }

    return false
  }
}
```

# 大数相加

```js
// 题目
let a = "9007199254740991"
let b = "1234567899999999999"

function bigIntAdd(a, b) {
  const len = Math.max(a.length, b.length)
  a = a.padStart(len, "0")
  b = b.padStart(len, "0")
  let carry = 0
  let result = ""
  for (let i = len - 1; i >= 0; i--) {
    const sum = parseInt(a[i]) + parseInt(b[i]) + carry
    const num = sum % 10
    carry = Math.floor(sum / 10)
    result = num + result
  }
  return result
}

console.log(bigIntAdd(a, b))
```

# 大数相乘

```js

```

# 大数相除

```js

```

# 大数相减

```js

```

# 版本号比较

给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点 '.' 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。

比较版本号时，请按 从左到右的顺序 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 0。

返回规则如下：

如果 version1 < version2 返回 -1，
如果 version1 > version2 返回 1，
除此之外返回 0。

```js
function compareVersion(version1: string, version2: string): number {
  const version1Arr = version1.split(".")
  const version2Arr = version2.split(".")
  const len = Math.max(version1Arr.length, version2Arr.length)
  for (let i = 0; i < len; i++) {
    const v1 = version1Arr[i] || "0"
    const v2 = version2Arr[i] || "0"
    if (parseInt(v1) === parseInt(v2)) continue
    if (parseInt(v1) > parseInt(v2)) {
      return 1
    } else {
      return -1
    }
  }
  return 0
}
```

# 版本号排序

```js
const arr = ["1.1.1", "1.1.2", "1.2.1", "1.2.2", "2.0.1", "2.0.2"]

function compareVersion(arr) {
  return arr.sort((a, b) => {
    const aArr = a.split(".")
    const bArr = b.split(".")
    const len = Math.max(aArr.length, bArr.length)
    for (let i = 0; i < len; i++) {
      const v1 = aArr[i] || "0"
      const v2 = bArr[i] || "0"
      if (parseInt(v1) === parseInt(v2)) continue
      if (parseInt(v1) > parseInt(v2)) {
        return -1
      } else {
        return 1
      }
    }
    return 0
  })
}

console.log(compareVersion(arr))
```

# 请实现 DOM2JSON 一个函数，可以把一个 DOM 节点输出 JSON 的格式

```js
const dom = {
  tag: "DIV",
  attributes: {
    id: "app",
  },
  children: [
    {
      tag: "SPAN",
      children: [{ tag: "A", children: [] }],
    },
    {
      tag: "SPAN",
      children: [
        { tag: "A", children: [] },
        { tag: "A", children: [] },
      ],
    },
  ],
}

function dom2json(jsonDom) {
  if (jsonDom.length === 0) return jsonDom
  const { tag, children, attributes } = jsonDom
  const dom = document.createElement(tag.toLowerCase())
  attributes &&
    Object.keys(attributes).forEach((key) =>
      dom.setAttribute(key, attributes[key])
    )
  children.forEach((child) => dom.appendChild(dom2json(child)))
  return dom
}

console.log(dom2json(dom))
```

# 实现分页

# 怎么在制定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）

# 实现一个 padStart()或 padEnd()的 polyfil

```js
// 实现一个padStart()或padEnd()的polyfil

String.prototype.myPadStart = function (targetLen, str) {
  const originLen = str.length
  const targetL = targetLen - originLen
  let result = this
  let s = ""
  for (let i = 0; i < targetL; i++) {
    for (let j = 0; j < originLen; j++) {
      if (targetL === s.length) break
      s = str[j] + s
    }
    if (targetL === s.length) break
  }
  result = s.split("").reverse().join("") + result
  return result
}

String.prototype.myPadStart = function (targetLen, padString = " ") {
  if (!targetLen) {
    throw new Error("请传入需要填充的长度")
  }
  const padStrLen = padString.length
  if (!padStrLen) return this

  const originLen = this.length
  const prefixLen = Math.max(0, targetLen - originLen)
  const repeatTimes = Math.ceil(prefixLen / padStrLen)
  return `${padString.repeat(repeatTimes).substring(0, prefixLen)}${this}`
}

String.prototype.myPadEnd = function (targetLen, str) {
  const originLen = str.length
  const targetL = targetLen - originLen
  let result = this
  for (let i = 0; i < targetL; i++) {
    for (let j = 0; j < originLen; j++) {
      if (targetLen === result.length) break
      result = result + str[j]
    }
    if (targetLen === result.length) break
  }
  return result
}
```

# 打乱数组

```js
//打乱数组
function shuffle(arr) {
  for (let i = 0; i < arr.length; i++) {
    // i-arr.length这个范围的random
    const random = i + Math.floor(Math.random() * (arr.length - i))
    //进行打乱
    ;[arr[i], arr[random]] = [arr[random], arr[i]]
  }
  return arr
}

console.log(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))

// 怎么在制定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）

//方法一
function getRandomArray(arr, n) {
  const result = []

  for (let i = 0; i < n; i++) {
    const random = Math.floor(Math.random() * arr.length)
    if (result.includes(arr[random])) {
      i--
      continue
    }
    if (result.length === n) break
    result.push(arr[random])
  }
  return result
}

//方法二
function getRandomArray2(arr, n) {
  const hash = {}
  const result = []
  let randomNum = n
  while (randomNum > 0) {
    const random = Math.floor(Math.random() * arr.length)
    if (!hash[random]) {
      hash[random] = true
      result.push(arr[random])
      randomNum--
    }
  }
  return result
}
console.log(getRandomArray2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3))
//方法三
function getTenNum(testArray, n) {
  const cloneArr = [...testArray]
  let result = []
  for (let i = 0; i < n; ++i) {
    const random = Math.floor(Math.random() * cloneArr.length)
    const cur = cloneArr[random]
    result.push(cur)
    cloneArr.splice(random, 1)
  }
  return result
}
const testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
const resArr = getTenNum(testArray, 10)
console.log(resArr, testArray)
```

# 查找数组公共前缀

```js
// 编写一个函数来查找字符串数组中的最长公共前缀。
// 如果不存在公共前缀，返回空字符串 ""。

// 示例 1：

// 输入：strs = ["flower","flow","flight"]
// 输出："fl"

// 示例 2：

// 输入：strs = ["dog","racecar","car"]
// 输出：""
// 解释：输入不存在公共前缀。

function getCommonPrefix(arr) {
  let result = ""
  for (let i = 0; i < arr[0].length; i++) {
    for (let j = 1; j < arr.length; j++) {
      if (arr[0][i] !== arr[j][i]) {
        return result
      }
    }
    result += arr[0][i]
  }
  return result
}
console.log(getCommonPrefix(["flower", "flow", "flight"]))
console.log(getCommonPrefix(["dog", "racecar", "car"]))
```

# 判断括号字符串是否有效（小米）

```js
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

// 有效字符串需满足：
// - 左括号必须用相同类型的右括号闭合。
// - 左括号必须以正确的顺序闭合。

// 示例 1：

// 输入：s = "()"
// 输出：true

// 示例 2：

// 输入：s = "()[]{}"
// 输出：true

// 示例 3：

// 输入：s = "(]"
// 输出：false

const isValid = function (s) {
  if (s.length % 2 === 1) {
    return false
  }
  const regObj = {
    "{": "}",
    "(": ")",
    "[": "]",
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "{" || s[i] === "(" || s[i] === "[") {
      stack.push(s[i])
    } else {
      const cur = stack.pop()
      if (s[i] !== regObj[cur]) {
        return false
      }
    }
  }

  if (stack.length) {
    return false
  }

  return true
}

function isValid(s) {
  if (s.length % 2 !== 0) return false
  const stack = []
  for (let i = 0; i < s.length; i++) {
    switch (s[i]) {
      case "(":
        stack.push(")")
        break
      case "{":
        stack.push("}")
        break
      case "[":
        stack.push("]")
        break
      default:
        if (stack.pop() !== s[i]) return false
    }
  }
  return stack.length === 0
}

console.log(isValid("()"))
console.log(isValid("()[]{}"))
console.log(isValid("(]"))

//嵌套的深度怎么计算

function getMaxDepth(s) {
  const stack = []
  let maxDepth = 0
  let currentDepth = 0

  for (let char of s) {
    if (char === "(" || char === "{" || char === "[") {
      currentDepth++
      maxDepth = Math.max(maxDepth, currentDepth)
      stack.push(char)
    } else {
      if (
        (char === ")" && stack[stack.length - 1] === "(") ||
        (char === "}" && stack[stack.length - 1] === "{") ||
        (char === "]" && stack[stack.length - 1] === "[")
      ) {
        stack.pop()
        currentDepth--
      }
    }
  }

  return maxDepth
}

// 测试用例
console.log(getMaxDepth("()")) // 输出: 1
console.log(getMaxDepth("()[]{}")) // 输出: 1
console.log(getMaxDepth("([])")) // 输出: 2
console.log(getMaxDepth("([{}])")) // 输出: 3
console.log(getMaxDepth("([})")) // 输出: 2
```

# 设计一个方法提取对象中所有 value 大于 2 的键值对并返回最新的对象

```js
const obj = { a: 1, b: 3, c: 4 }
foo(obj) // { b: 3, c: 4 }

function foo(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key, value]) => value > 2)
  )
}

console.log(foo(obj))
```

# 复原 IP 地址

```js
function restoreIpAddresses(s: string): string[] {
  const res = []
  const backtracking = (subRes, start) => {
    if (subRes.length === 4 && start === s.length) {
      res.push(subRes.join("."))
      return
    }
    if (subRes.length === 4 && start < s.length) {
      return
    }

    for (let len = 1; len <= 3; len++) {
      if (start + len - 1 > s.length) return
      if (len !== 1 && s[start] === "0") return
      const str = s.substring(start, start + len)
      if (len === 3 && +str > 255) return

      subRes.push(str)
      backtracking(subRes, start + len)
      subRes.pop()
    }
  }
  backtracking([], 0)
  return res
}
```

# 验证 IP 地址

# 对象的扁平化

```js
function flatObject(obj, prefix = "") {
  const result = {}
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        if (typeof item === "object" && item !== null) {
          Object.assign(result, flatObject(item, `${newKey}[${index}]`))
        } else {
          result[`${newKey}[${index}]`] = item
        }
      })
    } else if (
      typeof value === "object" &&
      value !== null &&
      !Array.isArray(value)
    ) {
      Object.assign(result, flatObject(value, newKey))
    } else {
      result[newKey] = value
    }
  }
  return result
}

//测试
const obj = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3,
    },
  },
  f: [1, 2, { g: 3 }],
}

console.log(flatObject(obj))
```

# js 实现 input 双向绑定

```js
<input type="text" id="input">
<span id="text"></span>

<script>
const input = document.getElementById('input')
const text = document.getElementById('text')

const data = new Proxy({
  value: ''
}, {
  get(target, key) {
    return target[key]
  },
  set(target, key, value) {
    target[key] = value
    // 更新视图
    input.value = value
    text.textContent = value
    return true
  }
})

// 监听输入
input.addEventListener('input', function(e) {
  data.value = e.target.value
})
</script>
```

# 手写弹窗组件

```js
import React, { useState } from "react"
import ReactDOM from "react-dom"
import "./modal.css" // 确保添加样式

const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null

  return ReactDOM.createPortal(
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        {children}
      </div>
    </div>,
    document.body
  )
}

const App = () => {
  const [isModalOpen, setModalOpen] = useState(false)

  const openModal = () => setModalOpen(true)
  const closeModal = () => setModalOpen(false)

  return (
    <div>
      <h1>弹窗示例</h1>
      <button onClick={openModal}>打开弹窗</button>
      <Modal isOpen={isModalOpen} onClose={closeModal}>
        <h2>这是弹窗内容</h2>
        <p>你可以在这里放任何你想要的内容。</p>
        <button onClick={closeModal}>关闭弹窗</button>
      </Modal>
    </div>
  )
}

export default App
```

## vue 写法

```vue
<template>
  <teleport to="body">
    <div v-if="isVisible" class="modal-overlay" @click="close">
      <div class="modal-content" @click.stop>
        <h2>这是一个弹窗</h2>
        <p>你可以在这里放置内容。</p>
        <button @click="close">关闭弹窗</button>
      </div>
    </div>
  </teleport>
</template>

<script>
export default {
  data() {
    return {
      isVisible: true, // 控制弹窗是否显示
    }
  },
  methods: {
    close() {
      this.isVisible = false // 关闭弹窗
    },
  },
}
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  width: 300px;
}

button {
  margin-top: 10px;
}
</style>
```

# css

## 二栏布局

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style></style>
  </head>
  <body>
    <!-- .container {
        position: relative;
      }
      .left {
        width: 200px;
        position: absolute;
        left: 0;
        top: 0;
        background-color: red;
      }
      .right {
        margin-left: 200px;
        background-color: blue;
      } -->
    <!-- .container {
        width: 100%;
      }
      .left {
        float: left;
        width: 200px;
        height: 100%;
        background-color: red;
      }
      .right {
        float: left;
        width: calc(100% - 200px);
        height: 100%;
        background-color: blue; -->
    <!-- } -->

    <!-- .container {
        width: 100%;
        height: 100%;
        display: flex;
      }
      .left {
        width: 200px;
        height: 100%;
        background-color: red;
      }
      .right {
        flex: 1;
        height: 100%;
        background-color: blue;
      } -->
    <div class="container">
      <div class="left">左</div>
      <div class="right">右</div>
    </div>
  </body>
</html>
```

# 手写 koa

```js
class Koa {
  constructor() {
    this.middlewares = []
  }

  // 注册中间件
  use(middleware) {
    this.middlewares.push(middleware)
  }

  // 核心：洋葱模型的中间件执行机制
  compose(ctx) {
    const dispatch = (i) => {
      if (i >= this.middlewares.length) return Promise.resolve() // 终止条件
      const middleware = this.middlewares[i] // 获取当前中间件
      return Promise.resolve(middleware(ctx, () => dispatch(i + 1))) // 执行当前中间件，并传递 `next`
    }
    return dispatch(0)
  }

  // 创建 HTTP 服务器
  listen(port, callback) {
    const http = require("http")
    const server = http.createServer(async (req, res) => {
      const ctx = { req, res } // 简单模拟 ctx
      await this.compose(ctx) // 触发中间件执行
      res.end(ctx.body || "Koa Response") // 统一响应
    })
    server.listen(port, callback)
  }
}
```
