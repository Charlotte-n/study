# 数组

## 合并区间

```js

```

## 二分查找

### 二分查找

```js
function search(arr, target) {
  let left = 0,
    right = arr.length - 1,
    mid
  while (left <= right) {
    mid = Math.floor((left + right) / 2)
    if (arr[mid] === target) {
      return mid
    } else if (arr[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return -1
}

console.log(search([-1, 0, 3, 5, 9, 12], 2))
```

### 搜索插入位置

```js
function insertPos(arr, target) {
  let left = 0,
    right = arr.length - 1
  let mid
  while (left <= right) {
    mid = Math.floor((right + left) / 2)
    if (arr[mid] === target) {
      return mid
    } else if (arr[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return left
}

console.log(insertPos([1, 3, 5, 6], 0))
```

### 在排序数组中查找元素的第一个和最后一个位置

```js
// 示例 1：

// 输入：nums = [5,7,7,8,8,10], target = 8
// 输出：[3,4]
// 示例 2：

// 输入：nums = [5,7,7,8,8,10], target = 6
// 输出：[-1,-1]
// 示例 3：

// 输入：nums = [], target = 0
// 输出：[-1,-1]

function searchPos(arr, target) {
  if (arr.length === 0) return [-1, -1]
  let mid,
    left = 0,
    right = arr.length - 1
  while (left <= right) {
    mid = Math.floor((right + left) / 2)
    if (arr[mid] === target) {
      ;(left = mid), (right = mid)
      while (arr[left] === target) {
        left--
      }

      while (arr[right] === target) {
        right++
      }
      return [left + 1, right - 1]
    } else if (arr[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return [-1, -1]
}

console.log(searchPos([], 0))
```

### x 的平方根

```js
function mySqrt(x) {
  let left = 0,
    right = x
  while (left <= right) {
    const mid = Math.floor((right + left) / 2)
    if (mid * mid < x) {
      left = mid + 1
    } else if (mid * mid > x) {
      right = mid - 1
    } else {
      return mid
    }
  }
  return right
}

console.log(mySqrt(8))
```

### 有效的平方根

```js
function mySqrt(x) {
  let left = 0,
    right = x
  while (left <= right) {
    const mid = Math.floor((right + left) / 2)
    if (mid * mid < x) {
      left = mid + 1
    } else if (mid * mid > x) {
      right = mid - 1
    } else {
      return true
    }
  }
  return false
}

console.log(mySqrt(8))
```

## 移除元素

```js
// 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

// 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

function removeElement(arr, val) {
  let len = arr.length
  for (let i = 0; i < len; i++) {
    if (arr[i] === val) {
      arr.splice(i, 1)
      i--
      len--
    }
  }
}

const arr = [0, 1, 2, 2, 3, 0, 4, 2]
removeElement(arr, 2)
console.log(arr)

// console.log()
```

## 移动零

```js
// 示例 1:

// 输入: nums = [0,1,0,3,12]
// 输出: [1,3,12,0,0]
// 示例 2:

// 输入: nums = [0]
// // 输出: [0]

/**
 Do not return anything, modify nums in-place instead.
 */
function moveZeroes(nums: number[]): void {
  let index = 0
  let count = 0
  while (count !== nums.length - 1) {
    if (nums[index] === 0) {
      nums.splice(index, 1)
      nums.push(0)
      index--
    }
    index++
    count++
  }
}
```

## 比较含字符串的退格

```js
function backspaceCompare(s: string, t: string): boolean {
   return delWord(s) === delWord(t)

};

function delWord = (word)=>{
    let res = []
    let wordArr = word.split('')
    let del = 0
    while(wordArr.length){
        const char = wordArr.pop()
        if(char === '#'){
            del++
        }else{
            if(del === 0){
                res.unshift(char)
            }else{
                del--
            }
        }

    }
    return res.join('')
}
```

## 有序数组的平方

```js
// 示例 1：

// 输入：nums = [-4,-1,0,3,10]
// 输出：[0,1,9,16,100]
// 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
// 示例 2：

// 输入：nums = [-7,-3,2,3,11]
// 输出：[4,9,9,49,121]
// #

function sortedSquares(arr) {
  let i = 0,
    j = arr.length - 1,
    k = arr.length - 1
  let res = new Array(arr.length).fill(0)

  while (i <= j) {
    let left = arr[i] * arr[i]
    let right = arr[j] * arr[j]
    if (left < right) {
      res[k--] = right
      j--
    } else {
      res[k--] = left
      i++
    }
  }
  return res
}
```

## 长度最小的子数组

```js
function minSubArrayLen(target: number, nums: number[]): number {
  let sum = 0,
    len = nums.length
  for (let i = 0, j = 0; j < nums.length; j++) {
    sum += nums[j]
    while (sum >= target) {
      len = Math.min(len, j - i + 1)
      sum -= nums[i++]
    }
  }
  return len === nums.length ? 0 : len
}
```

## 螺旋矩阵

```js
function spiralOrder(matrix: number[][]): number[] {
  let top = 0,
    bottom = matrix.length - 1,
    left = 0,
    right = matrix[0].length - 1
  const result = []
  while (true) {
    for (let i = left; i <= right; i++) {
      result.push(matrix[top][i])
    }
    top++
    if (top > bottom) {
      break
    }
    for (let i = top; i <= bottom; i++) {
      result.push(matrix[i][right])
    }
    right--
    if (right < left) break
    for (let i = right; i >= left; i--) {
      result.push(matrix[bottom][i])
    }
    bottom--
    if (bottom < top) break
    for (let i = bottom; i >= top; i--) {
      result.push(matrix[i][left])
    }
    left++
    if (left > right) break
  }
  return result
}
```

## 螺旋矩阵二

```js
var generateMatrix = function (n) {
  const matrix = new Array(n)
  for (let i = 0; i < n; i++) {
    matrix[i] = new Array(n)
  }
  let num = 1
  let left = 0,
    right = n - 1,
    top = 0,
    bottom = n - 1
  while (num <= n * n) {
    for (let i = left; i <= right; i++) {
      matrix[top][i] = num
      num++
    }
    top++
    for (let i = top; i <= bottom; i++) {
      matrix[i][right] = num
      num++
    }
    right--
    for (let i = right; i >= left; i--) {
      matrix[bottom][i] = num
      num++
    }
    bottom--
    for (let i = bottom; i >= top; i--) {
      matrix[i][left] = num
      num++
    }
    left++
  }
  return matrix
}
```

# 链表

## 移除

```js
// 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

// 示例 2： 输入：head = [], val = 1 输出：[]

// 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

// #

const removeElement = (head, val) => {
  const pre = new ListNode(0, head)
  const curr = pre

  while (curr.next) {
    if (curr.next.val === val) {
      curr.next = curr.next.next
      continue
    }
    curr = curr.next
  }
  return pre.next
}
```

## 设计链表

```js
class LinkNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? undefined : next
  }
}

class Link {
  constructor() {
    this.size = 0
    this.head = null
    this.tail = null
  }
  // 获取链表中第 index个节点的值
  get(index) {
    if (index < 0 || index > this.size) {
      throw new Error("出错了")
    }
    const currNode = this.getNode(index)
    return currNode
  }
  //获取相关Node
  getNode(index) {
    let currentNode = new ListNode(0, this.head)
    for (let i = 0; i <= index; i++) {
      currentNode = currentNode.next
    }
    return currentNode
  }

  //// 在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。
  addAtHead(val) {
    const node = new ListNode(val, this.head)
    this.head = node
    if (!this.tail) {
      this.tail = node
    }
    this.size++
  }
  // 将值为 val 的节点追加到链表的最后一个元素。
  addAtTail(val) {
    const node = new ListNode(val, null)
    if (!this.tail && this.head) {
      this.head.next = node
    } else if (!this.head && !this.head) {
      this.head = this.tail = node
    } else {
      this.tail.next = node
    }
    this.size++
    this.tail = node
  }
  //// 在链表中的第 index个节点之前添加值为 val的节点。
  // 如果 index等于链表的长度，则该节点将附加到链表的末尾。如果 index大于链表长度，则不会插入节点。如果 index小于0，则在头部插入节点。
  addAtIndex(index, val) {
    if (index === this.size) {
      this.addAtTail(val)
    }

    if (index <= 0) {
      this.addAtHead(val)
    }

    //正常添加
    const preNode = this.getNode(index - 1)
    const node = new ListNode(val, preNode.next)
    preNode.next = node
    this.size++
  }
  //在指定位置相减
  deleteAtIndex(index) {
    if (index < 0 || index >= this.size) {
      return
    }
    if (index === 0) {
      this.head = this.head.next
      if (index === this.size - 1) {
        this.tail = null
      }
      this.size--
      return
    }
    const preNode = this.getNode(index - 1)
    preNode.next = preNode.next.next
    if (this.size - 1 === index) {
      this.tail = preNode
    }
    this.size--
  }
}
```

## 翻转链表

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

```js
function reverseList(head) {
  let pre = null
  let current = head
  while (current) {
    let temp = current.next
    current.next = pre
    pre = current
    current = temp
  }
  return pre
}
```

## 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
  let dummy = new ListNode(0, head)
  let pre = dummy
  while (pre.next !== null && pre.next.next !== null) {
    let temp1 = pre.next
    let temp2 = pre.next.next
    temp1.next = temp2.next
    temp2.next = temp1
    pre.next = temp2
    pre = temp1
  }
  return dummy.next
}
```

## 删除链表的倒数第 N 个节点

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
  //获取链表长度
  let len = 0

  let dummy = new ListNode(0, head)
  let curr = dummy

  while (head) {
    len++
    head = head.next
  }
  console.log(len)
  for (let i = 0; i < len - n; i++) {
    curr = curr.next
  }
  curr.next = curr.next.next
  return dummy.next
}
```

## 链表相交

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  if (headA === null || headB === null) return null
  let A = headA,
    B = headB
  while (A !== B) {
    A = A === null ? headB : A.next
    B = B === null ? headA : B.next
  }
  return A
}
```

## 环形链表 II

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  //是否为环形
  let fast = head,
    slow = head
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      break
    }
  }
  if (fast === null || fast.next === null) {
    return null
  }

  slow = head
  while (fast !== slow) {
    fast = fast.next
    slow = slow.next
  }
  return fast
}
```

# 哈希表

## 有效的字母异位符

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function (s, t) {
  const map = new Map()
  for (let i = 0; i < s.length; i++) {
    map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1)
  }
  for (let i = 0; i < t.length; i++) {
    if (!map.has(t[i])) {
      return false
    } else {
      if (map.get(t[i]) === 1) {
        map.delete(t[i])
      } else {
        map.set(t[i], map.get(t[i]) - 1)
      }
    }
  }
  return map.size === 0
}
```

## 字母异位符分组

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {
  const hash = new Map()
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i].split("").sort().join("")
    hash.set(str, hash.has(str) ? [...hash.get(str), strs[i]] : [strs[i]])
  }
  return [...hash.values()]
}
```

## 找到字符串中的所有字母异位符

```js
// 示例 1:

// 输入: s = "cbaebabacd", p = "abc"
// 输出: [0,6]
// 解释:
// 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
// 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
//  示例 2:

// 输入: s = "abab", p = "ab"
// 输出: [0,1,2]
// 解释:
// 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
// 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
// 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

var findAnagrams = function (s, p) {
  let need = {}
  let window = {}
  let result = []
  let left = 0
  let right = 0
  let valid = 0
  Array.from(p).forEach((item) =>
    need[item] ? (need[item] = need[item] + 1) : (need[item] = 1)
  )
  while (right < s.length) {
    const char = s[right]
    right++
    if (need[char]) {
      window[char] = window[char] ? window[char] + 1 : 1
      if (window[char] === need[char]) {
        valid++
      }
    }

    //判断这个范围是否到达了
    while (right - left >= p.length) {
      if (valid === Object.keys(need).length) {
        result.push(left)
      }

      const char = s[left]
      left++
      if (need[char]) {
        if (window[char] === need[char]) {
          valid--
        }
        window[char] = window[char] - 1
      }
    }
  }
  return result
}

const s = "acc"
const p = "cc"
console.log(findAnagrams(s, p))
```

## 数组交集

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function (nums1, nums2) {
  const hash = {}
  const result = []
  nums1.forEach((item) => {
    hash[item] = hash[item] ? hash[item] + 1 : 1
  })
  for (let i = 0; i < nums2.length; i++) {
    if (hash[nums2[i]]) {
      result.push(nums2[i])
    }
  }
  return [...new Set(result)]
}
```

## 快乐数

```js
/**
 * @param {number} n
 * @return {boolean}
 */
function getSum(n) {
  let sum = 0
  while (n) {
    sum += (n % 10) ** 2
    n = Math.floor(n / 10)
  }
  return sum
}
var isHappy = function (n) {
  const set = new Set()
  while (n !== 1 && !set.has(n)) {
    set.add(n)
    n = getSum(n)
  }
  return n === 1
}
```

## 两数之和

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  const hash = {}
  for (let i = 0; i < nums.length; i++) {
    const diff = target - nums[i]
    if (hash[diff] === 0 || hash[diff]) {
      return [hash[diff], i]
    }
    hash[nums[i]] = i
  }
  return [-1, -1]
}
```

## 四数相加

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[]} nums3
 * @param {number[]} nums4
 * @return {number}
 */
var fourSumCount = function (nums1, nums2, nums3, nums4) {
  const map = new Map()
  let count = 0
  for (let n1 of nums1) {
    for (let n2 of nums2) {
      const sum = n1 + n2
      map.set(sum, (map.get(sum) || 0) + 1)
    }
  }

  for (let n1 of nums3) {
    for (let n2 of nums4) {
      const result = 0 - n1 - n2
      if (map.has(result)) {
        count += map.get(result)
      }
    }
  }
  return count
}
```

## 赎金信

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function (ransomNote, magazine) {
  const map = new Map()
  for (let i = 0; i < magazine.length; i++) {
    map.set(magazine[i], (map.get(magazine[i]) || 0) + 1)
  }
  for (let i = 0; i < ransomNote.length; i++) {
    if (map.has(ransomNote[i])) {
      map.set(ransomNote[i], map.get(ransomNote[i]) - 1)
      if (map.get(ransomNote[i]) === 0) {
        map.delete(ransomNote[i])
      }
    } else {
      return false
    }
  }
  return true
}
```

## n 数之和

```js
function threeSum(nums) {
  return nSums(nums, 0, 3)
}

function nSums(arr, target, n) {
  if (n <= 1) return []
  arr.sort((a, b) => a - b)
  return help(arr, target, n)
}

function help(arr, target, n, l = 0, r = arr.length) {
  const ans = []
  if (n === 2) {
    for (let i = l, j = r - 1; i < r; i++) {
      //重复
      if (i > l && arr[i] === arr[i - 1]) continue
      if (i < j && arr[i] + arr[j] > target) j--
      if (i < j && arr[i] + arr[j] == target) {
        ans.push([arr[i], arr[j]])
      }
    }
  } else {
    for (let i = l; i < r; i++) {
      if (i > l && arr[i] === arr[i - 1]) continue
      const temp = help(arr, target - arr[i], n - 1, i + 1, r)
      if (temp.length) {
        temp.forEach((item) => item.push(arr[i]))
        ans.push(...temp)
      }
    }
  }
  return ans
}
```

### 三数之和

### 四数之和

## 多数之和

# 字符串

## 反转字符串

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
  const len = s.length
  const mid = Math.floor(s.length / 2)
  for (let i = 0; i < mid; i++) {
    let j = len - 1 - i
    const temp = s[i]
    s[i] = s[j]
    s[j] = temp
  }
  return s
}
```

## 反转字符串 II

```js
var reverseStr = function (s, k) {
  const len = s.length
  let resArr = s.split("")
  for (let i = 0; i < len; i += 2 * k) {
    let l = i - 1,
      r = i + k > len ? len : i + k
    while (++l < --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]]
  }
  return resArr.join("")
}
```

## 反转字符串的单词

```js
// 示例 1：

// 输入：s = "the sky is blue"
// 输出："blue is sky the"
// 示例 2：

// 输入：s = "  hello world  "
// 输出："world hello"
// 解释：反转后的字符串中不能存在前导空格和尾随空格。

/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function (s) {
  let res = ""
  for (let value of s.split(" ").reverse()) {
    if (value.trim()) {
      res = res + " " + value
    }
  }
  return res.trim()
}
```

## 找出字符串中第一个匹配项的下标

```js
// 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
// 示例 1：

// 输入：haystack = "sadbutsad", needle = "sad"
// 输出：0
// 解释："sad" 在下标 0 和 6 处匹配。
// 第一个匹配项的下标是 0 ，所以返回 0 。
// 示例 2：

// 输入：haystack = "leetcode", needle = "leeto"
// 输出：-1
// 解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function (haystack, needle) {
  for (let i = 0; i < haystack.length; i++) {
    if (haystack[i] === needle[0]) {
      if (haystack.slice(i, i + needle.length) === needle) {
        return i
      }
    }
  }
  return -1
}
```

## 重复的子字符串

```js
// 示例 1:

// 输入: s = "abab"
// 输出: true
// 解释: 可由子串 "ab" 重复两次构成。
// 示例 2:

// 输入: s = "aba"
// 输出: false
// 示例 3:

// 输入: s = "abcabcabcabc"
// 输出: true
// 解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function (s) {
  let str = ""
  for (let i = 0; i < s.length - 1; i++) {
    str += s[i]
    if (s === str.repeat(Math.floor(s.length / str.length))) {
      return true
    }
  }
  return false
}
```

# 栈和队列

## 栈实现队列

```js
class MyQueue {
  queue
  constructor() {
    this.queue = []
  }

  push(x: number): void {
    this.queue.push(x)
  }

  pop(): number {
    return this.queue.shift()
  }

  peek(): number {
    return this.queue[0]
  }

  empty(): boolean {
    return this.queue.length === 0
  }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

## 队列实现栈

```js
class MyStack {
  stack
  constructor() {
    this.stack = []
  }

  push(x: number): void {
    this.stack.push(x)
  }

  pop(): number {
    return this.stack.pop()
  }

  top(): number {
    return this.stack[this.stack.length - 1]
  }

  empty(): boolean {
    return this.stack.length === 0
  }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

## 有效的括号

```js
function isValid(s: string): boolean {
  const stack = []
  const mapObj = {
    "(": ")",
    "[": "]",
    "{": "}",
  }
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(" || s[i] === "{" || s[i] === "[") {
      stack.push(s[i])
      continue
    } else {
      const str = stack.pop()
      if (mapObj[str] !== s[i]) {
        return false
      }
    }
  }
  return stack.length === 0
}
```

## 删除字符串中的所有相邻重复项

```js
function removeDuplicates(s: string): string {
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (stack.length !== 0 && stack[stack.length - 1] === s[i]) {
      while (stack[stack.length - 1] === s[i]) {
        stack.pop()
      }
      continue
    }
    stack.push(s[i])
  }

  return stack.join("")
}
```

## 逆波兰表达式求值

```js
function evalRPN(tokens: string[]): number {
  if (tokens.length === 1) {
    return parseInt(tokens.pop())
  }
  const stack = []
  const sign = {
    "+": (a, b) => a + b,
    "-": (a, b) => a - b,
    "*": (a, b) => a * b,
    "/": (a, b) => (a / b) | 0,
  }
  for (let i = 0; i < tokens.length; i++) {
    //判断是否为+-*/
    if (Object.keys(sign).includes(tokens[i])) {
      const num1 = parseInt(stack.pop())
      const num2 = parseInt(stack.pop())
      const fn = sign[tokens[i]]
      stack.push(fn(num2, num1))
      continue
    }
    stack.push(+tokens[i])
  }
  return stack.pop()
}
```

## 前 n 个高频元素

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {
  const map = new Map()
  const result = []
  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      map.set(nums[i], map.get(nums[i]) + 1)
    } else {
      map.set(nums[i], 1)
    }
  }
  //a降序
  const sortArray = [...map].sort((a, b) => b[1] - a[1])
  for (let i = 0; i < k; i++) {
    result.push(sortArray[i][0])
  }
  return result
}
```

# 二叉树

## 前序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return
    result.push(root.val)
    dfs(root.left)
    dfs(root.right)
  }
  dfs(root)
  return result
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
  if (!root) return []
  const stack = []
  const result = []
  stack.push(root)
  while (stack.length) {
    const node = stack.pop()
    result.push(node.val)
    if (node.right) stack.push(node.right)
    if (node.left) stack.push(node.left)
  }
  return result
}
```

## 后序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return
    dfs(root.left)
    dfs(root.right)
    result.push(root.val)
  }
  dfs(root)
  return result
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {
  if (!root) return []
  const stack = []
  stack.push(root)
  const result = []
  while (stack.length) {
    const node = stack.pop()
    result.push(node.val)
    if (node.left) stack.push(node.left)
    if (node.right) stack.push(node.right)
  }
  return result.reverse()
}
```

## 中序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return root
    dfs(root.left)
    result.push(root.val)
    dfs(root.right)
  }
  dfs(root)
  return result
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  const stack = []
  const result = []
  let curr = root
  while (stack.length || curr) {
    if (curr) {
      stack.push(curr)
      curr = curr.left
    } else {
      curr = stack.pop()
      result.push(curr.val)
      curr = curr.right
    }
  }
  return result
}
```

## 层序遍历

### 层序遍历一

```js
var levelOrder = function (root) {
  const queue = [],
    result = []
  if (!root) return result
  queue.push(root)
  while (queue.length) {
    const ceng = []
    const length = queue.length
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      ceng.push(node.val)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    result.push(ceng)
  }
  return result
}
```

### 层序遍历二

给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```js
var levelOrderBottom = function (root) {
  const queue = [],
    result = []
  if (!root) return result
  queue.push(root)
  while (queue.length) {
    const ceng = []
    const length = queue.length
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      ceng.push(node.val)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    result.unshift(ceng)
  }
  return result
}
```

### 二叉树右视图

```js
ar rightSideView = function(root) {
    //层序遍历的最后一个
    const queue = []
    const result = []
    if(!root)return result
    queue.push(root)
    while(queue.length){
        const length  = queue.length
        const ceng = []
        for(let i = 0;i < length;i++){
            const node = queue.shift()
            ceng.push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        result.push(ceng[ceng.length - 1])
    }
    return result
};
```

### 二叉树层平均

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function (root) {
  const queue = []
  const result = []
  if (!root) return result
  queue.push(root)
  while (queue.length) {
    const length = queue.length
    const ceng = []
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      ceng.push(node.val)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    result.push(ceng.reduce((pre, curr) => pre + curr) / ceng.length)
  }
  return result
}
```

### N 叉树层遍历

```js
/**
 * // Definition for a _Node.
 * function _Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {_Node|null} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  const queue = []
  const result = []
  if (!root) return result
  queue.push(root)
  while (queue.length) {
    const length = queue.length
    const ceng = []
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      ceng.push(node.val)
      for (let item of node.children) {
        item && queue.push(item)
      }
    }
    result.push(ceng)
  }
  return result
}
```

### 在每个树行中找最大值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function (root) {
  const queue = []
  const result = []
  if (!root) return result
  queue.push(root)
  while (queue.length) {
    const length = queue.length
    let max = -Infinity
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      max = Math.max(max, node.val)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    result.push(max)
  }
  return result
}
```

### 填充每个节点的下一个右侧节点指针

```js
var connect = function (root) {
  const queue = []
  if (!root) return root
  queue.push(root)
  root.next = null
  while (queue.length) {
    const length = queue.length
    const ceng = []
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      node.next = i === length - 1 ? null : queue[0]
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return root
}
```

### 最大深度

```js
var maxDepth = function (root) {
  const queue = []
  if (!root) return 0
  let max = 0
  queue.push(root)
  while (queue.length) {
    const length = queue.length
    max++
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return max
}
```

```js
var maxDepth = function (root) {
  if (!root) return 0
  let left = maxDepth(root.left)
  let right = maxDepth(root.right)
  return Math.max(left, right) + 1
}
```

### 二叉树的最小深度

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  if (root === null) return 0
  let queue = [root]
  let depth = 0
  while (queue.length) {
    let n = queue.length
    depth++
    for (let i = 0; i < n; i++) {
      let node = queue.shift()
      // 如果左右节点都是null(在遇见的第一个leaf节点上)，则该节点深度最小
      if (node.left === null && node.right === null) {
        return depth
      }
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return depth
}
```

```js
var minDepth1 = function (root) {
  if (!root) return 0
  // 到叶子节点 返回 1
  if (!root.left && !root.right) return 1
  // 只有右节点时 递归右节点
  if (!root.left) return 1 + minDepth(root.right)
  // 只有左节点时 递归左节点
  if (!root.right) return 1 + minDepth(root.left)
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1
}
```

## 翻转二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
function swap(root) {
  if (!root) return root
  const temp = root.left
  root.left = root.right
  root.right = temp
}
var invertTree = function (root) {
  if (!root) return root
  swap(root)
  invertTree(root.left)
  invertTree(root.right)
  return root
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
function swap(root) {
  if (!root) return root
  const temp = root.left
  root.left = root.right
  root.right = temp
}
var invertTree = function (root) {
  if (!root) return root
  const stack = []
  stack.push(root)
  while (stack.length) {
    const node = stack.pop()
    swap(node)
    if (node.right) stack.push(node.right)
    if (node.left) stack.push(node.left)
  }
  return root
}
```

## 对称二叉树

```js
function isSame(left, right) {
  if (left === null && right !== null) return false
  else if (left !== null && right === null) return false
  else if (left === null && right === null) return true
  else if (left.val != right.val) return false
  return isSame(left.left, right.right) && isSame(left.right, right.left)
}
var isSymmetric = function (root) {
  return isSame(root, root)
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

var isSymmetric = function (root) {
  if (!root) return true
  const queue = []
  queue.push(root.left)
  queue.push(root.right)
  while (queue.length) {
    const leftNode = queue.shift()
    const rightNode = queue.shift()
    if (leftNode === null && rightNode === null) {
      continue
    }
    if (
      leftNode === null ||
      rightNode === null ||
      leftNode.val !== rightNode.val
    ) {
      return false
    }
    queue.push(leftNode.left)
    queue.push(rightNode.right)
    queue.push(leftNode.right)
    queue.push(rightNode.left)
  }
  return true
}
```

### 相同的树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
function isEqual(p, q) {
  if (p === null && q === null) return true
  else if (p === null && q !== null) return false
  else if (p !== null && q === null) return false
  else if (p.val !== q.val) return false
  return isEqual(p.left, q.left) && isEqual(p.right, q.right)
}
var isSameTree = function (p, q) {
  return isEqual(p, q)
}
```

### 另一颗树的子树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} subRoot
 * @return {boolean}
 */
function isEqual(p, q) {
  if (p === null && q === null) return true
  else if (p === null && q !== null) return false
  else if (p !== null && q === null) return false
  else if (p.val !== q.val) return false
  return isEqual(p.left, q.left) && isEqual(p.right, q.right)
}
var isSubtree = function (root, subRoot) {
  if (root === null && subRoot === null) return true
  else if (root === null && subRoot !== null) return false
  else if (root !== null && subRoot === null) return true
  const stack = []
  stack.push(root)
  let flag = false
  while (stack.length) {
    const node = stack.pop()
    if (node.val === subRoot.val) {
      flag = isEqual(node, subRoot)
      if (flag === true) {
        return true
      }
    }
    node.right && stack.push(node.right)
    node.left && stack.push(node.left)
  }
  return flag
}
```

## n 叉树的最大深度

```js
var maxDepth = function (root) {
  if (!root) return 0
  let depth = 0
  for (let item of root.children) {
    if (item) {
      depth = Math.max(depth, maxDepth(item))
    }
  }
  return depth + 1
}
```

## 完全二叉树节点个数

```js
var countNodes = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return
    result.push(root.val)
    dfs(root.left)
    dfs(root.right)
  }
  dfs(root)
  return result.length
}
```

## 平衡二叉树

```js
var isBalanced = function (root) {
  function getDepth(root) {
    if (!root) return 0
    const left = getDepth(root.left)
    if (left === -1) return -1
    const right = getDepth(root.right)
    if (right === -1) return -1
    if (Math.abs(left - right) > 1) {
      return -1
    } else {
      return 1 + Math.max(left, right)
    }
  }
  return !(getDepth(root) === -1)
}
```

## 二叉树的所有路径

```js
var binaryTreePaths = function (root) {
  const result = []
  function getPath(root, path = "") {
    if (root.left === null && root.right === null) {
      path += root.val
      result.push(path)
      return
    }
    path += root.val + "->"
    root.left && getPath(root.left, path)
    root.right && getPath(root.right, path)
  }
  getPath(root, "")
  return result
}
```

## 左叶子之和

```js
var sumOfLeftLeaves = function (root) {
  let sum = 0
  function getSum(root) {
    if (root.left && root.left.left === null && root.left.right === null) {
      sum += root.left.val
    }
    root.left && getSum(root.left)
    root.right && getSum(root.right)
  }
  getSum(root)
  return sum
}
```

## 找树左下角的一只

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function (root) {
  //层序遍历拿到最后一层的最左边那个
  const queue = [root]
  const result = []
  while (queue.length) {
    const length = queue.length
    const ceng = []
    for (let i = 0; i < length; i++) {
      const node = queue.shift()
      ceng.push(node.val)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    result.push(ceng)
  }
  return result[result.length - 1][0]
}
```

## 路径总和

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {
  if (root === null) return false
  function has(root, targetSum) {
    if (root === null) {
      return false
    }
    if (
      root !== null &&
      root.left === null &&
      root.right === null &&
      targetSum === root.val
    ) {
      return true
    }
    const left = has(root.left, targetSum - root.val)
    const right = has(root.right, targetSum - root.val)
    return left || right
  }
  return has(root, targetSum)
}
```

## 中序后序遍历构建树

```js
var buildTree = function (inorder, postorder) {
  if (!inorder.length) return null
  const rootVal = postorder.pop()
  const rootIndex = inorder.indexOf(rootVal)
  const left = buildTree(
    inorder.slice(0, rootIndex),
    postorder.slice(0, rootIndex)
  )
  const right = buildTree(
    inorder.slice(rootIndex + 1),
    postorder.slice(rootIndex)
  )
  const root = new TreeNode(rootVal, left, right)
  return root
}
```

## 从前序和中序遍历序列构造二叉树

```js
var buildTree = function (preorder, inorder) {
  if (!inorder.length) return null
  const rootValue = preorder.shift()
  const rootIndex = inorder.indexOf(rootValue)
  const left = buildTree(
    preorder.slice(0, rootIndex),
    inorder.slice(0, rootIndex)
  )
  const right = buildTree(
    preorder.slice(rootIndex),
    inorder.slice(rootIndex + 1)
  )
  return new TreeNode(rootValue, left, right)
}
```

## 最大二叉树

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。

```js
var constructMaximumBinaryTree = function (nums) {
  if (nums.length === 0) return null
  const max = Math.max(...nums)
  const maxIndex = nums.indexOf(max)
  const root = new TreeNode(max)
  const left = nums.slice(0, maxIndex)
  const right = nums.slice(maxIndex + 1)
  root.left = constructMaximumBinaryTree(left)
  root.right = constructMaximumBinaryTree(right)
  return root
}
```

## 合并二叉树

```js
var mergeTrees = function (root1, root2) {
  if (root1 === null && root2) {
    return root2
  }
  if ((root1 && root2 === null) || (root1 === null && root2 === null)) {
    return root1
  }
  const root = new TreeNode(root1.val + root2.val)
  root.left = mergeTrees(root1.left, root2.left)
  root.right = mergeTrees(root1.right, root2.right)
  return root
}
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function (root1, root2) {
  if (!root1) return root2
  if (!root2) return root1
  const queue = []
  queue.push(root1)
  queue.push(root2)
  while (queue.length) {
    const node1 = queue.shift()
    const node2 = queue.shift()
    node1.val = node1.val + node2.val
    if (node1.left !== null && node2.left !== null) {
      queue.push(node1.left)
      queue.push(node2.left)
    }
    if (node1.right !== null && node2.right !== null) {
      queue.push(node1.right)
      queue.push(node2.right)
    }
    if (node1.left === null && node2.left !== null) {
      node1.left = node2.left
    }
    if (node1.right === null && node2.right !== null) {
      node1.right = node2.right
    }
  }
  return root1
}
```

## 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

```js
var searchBST = function (root, val) {
  const stack = []
  stack.push(root)
  while (stack.length) {
    const length = stack.length
    for (let i = 0; i < length; i++) {
      const node = stack.shift()
      if (node.val === val) {
        return node
      }
      node.left && stack.push(node.left)
      node.right && stack.push(node.right)
    }
  }
  return null
}

var searchBST = function (root, val) {
  while (root) {
    if (root.val > val) {
      root = root.left
    } else if (root.val < val) {
      root = root.right
    } else {
      return root
    }
  }
  return null
}
```

## 验证二叉树

中序递增

```js
const arr = []
function dfs(root) {
  if (!root) return
  dfs(root.left)
  arr.push(root.val)
  dfs(root.right)
}
dfs(root)
for (let i = 1; i < arr.length; i++) {
  if (arr[i - 1] >= arr[i]) {
    return false
  }
}
return true
```

## 二叉搜索树的最小绝对差

```js
var getMinimumDifference = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return
    dfs(root.left)
    result.push(root.val)
    dfs(root.right)
  }
  dfs(root)
  let min = +Infinity
  for (let i = 1; i < result.length; i++) {
    const res = result[i] - result[i - 1]
    if (res < min) {
      min = res
    }
  }
  return min
}
```

## 二叉树寻找众数

```js
var findMode = function (root) {
  const result = []
  function dfs(root) {
    if (!root) return
    dfs(root.left)
    result.push(root.val)
    dfs(root.right)
  }
  dfs(root)
  const hash = new Map()
  for (let i = 0; i < result.length; i++) {
    hash.set(result[i], (hash.get(result[i]) || 0) + 1)
  }
  let max = -Infinity
  let re = []
  for (let [key, value] of hash) {
    if (value === max) {
      re.push(key)
    }
    if (value > max) {
      re = []
      max = value
      re.push(key)
    }
  }
  return re
}
```

## 二叉树公共祖先

如果遍历到 p 或 q，比方说 p，则 LCA 要么是当前的 p（q 在 p 的子树中），要么是 p 之上的节点（q 不在 p 的子树中），不可能是 p 之下的节点，不用继续往下走，返回当前的 p。

当遍历到 null 节点，空树不存在 p 和 q，没有 LCA，返回 null。

当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右子树：

如果左右子树的递归都有结果，说明 p 和 q 分居 root 的左右子树，返回 root。
如果只是一个子树递归调用有结果，说明 p 和 q 都在这个子树，返回该子树递归结果。
如果两个子树递归结果都为 null，说明 p 和 q 都不在这俩子树中，返回 null。

```js
var lowestCommonAncestor = function (root, p, q) {
  if (!root) return root
  if (root === p || root === q) return root
  const left = lowestCommonAncestor(root.left, p, q)
  const right = lowestCommonAncestor(root.right, p, q)
  if (left && right) {
    return root
  }
  if (!left) return right
  return left
}
```

## 二叉树插入节点

在空白的二叉搜索树中插入节点

```js
var insertIntoBST = function (root, val) {
  function setRoot(root, val) {
    if (root === null) {
      let node = new TreeNode(val)
      return node
    }
    if (root.val > val) {
      root.left = setRoot(root.left, val)
    } else if (root.val < val) {
      root.right = setRoot(root.right, val)
    }
    return root
  }
  return setRoot(root, val)
}
```

## 修剪二叉树

```js
var trimBST = function (root, low, high) {
  if (root === null) return root
  if (root.val < low) {
    return trimBST(root.right, low, high)
  }
  if (root.val > high) {
    return trimBST(root.left, low, high)
  }
  root.left = trimBST(root.left, low, high)
  root.right = trimBST(root.right, low, high)
  return root
}
```

## 将有序数组转换为二叉搜索树

```js
var sortedArrayToBST = function (nums) {
  function dfs(nums) {
    if (nums.length === 0) {
      return null
    }
    const mid = Math.floor(nums.length / 2)
    let left = dfs(nums.slice(0, mid))
    let right = dfs(nums.slice(mid + 1))
    const root = new TreeNode(nums[mid], left, right)
    return root
  }
  return dfs(nums)
}
```

## 二叉树转化为累加树

```js
var convertBST = function (root) {
  let pre = 0
  const ReverseInOrder = (cur) => {
    if (cur) {
      ReverseInOrder(cur.right)
      cur.val += pre
      pre = cur.val
      ReverseInOrder(cur.left)
    }
  }
  ReverseInOrder(root)
  return root
}
```

# 回溯

## 组合

```js
var combine = function (n, k) {
  const result = []
  const path = []
  function backtracking(n, k, startIndex) {
    if (path.length === k) {
      result.push(path.slice())
      return
    }
    for (let i = startIndex; i <= n; i++) {
      path.push(i)
      backtracking(n, k, i + 1)
      path.pop()
    }
  }
  backtracking(n, k, 1)
  return result
}
```

## 组合 III

```js
var combinationSum3 = function (k, n) {
  const result = [],
    path = []
  function backtracking(k, n, startIndex = 1, sum = 0) {
    if (sum > n) {
      return
    }
    if (sum === n && k === path.length) {
      result.push(path.slice())
      return
    }

    for (let i = startIndex; i <= 9; i++) {
      path.push(i)
      sum += i
      backtracking(k, n, i + 1, sum)
      sum -= i
      path.pop()
    }
  }
  backtracking(k, n, 1, 0)
  return result
}
```

## 电话号码组合

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
  const result = []
  if (digits.length === 0) return result
  const strMap = {
    1: [],
    2: ["a", "b", "c"],
    3: ["d", "e", "f"],
    4: ["g", "h", "i"],
    5: ["j", "k", "l"],
    6: ["m", "n", "o"],
    7: ["p", "q", "r", "s"],
    8: ["t", "u", "v"],
    9: ["w", "x", "y", "z"],
  }

  function backtracking(digits, path, startIndex = 0) {
    if (path.length === digits.length) {
      result.push(path.join(""))
      return
    }
    const digitsArray = strMap[digits.split("")[startIndex]]
    for (let i = 0; i < digitsArray.length; i++) {
      path.push(digitsArray[i])
      backtracking(digits, path, startIndex + 1)
      path.pop()
    }
  }
  backtracking(digits, [], 0)
  return result
}
```

## 组合总和 I

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

```js
var combinationSum = function (candidates, target) {
  const result = [],
    path = []
  function backtracking(candidates, target, sum = 0, startIndex = 0) {
    if (sum > target) {
      return
    }
    if (sum === target) {
      result.push(path.slice())
      return
    }

    for (let i = startIndex; i < candidates.length; i++) {
      path.push(candidates[i])
      sum += candidates[i]
      backtracking(candidates, target, sum, i)
      sum -= candidates[i]
      path.pop()
    }
  }
  backtracking(candidates, target, 0, 0)
  return result
}
```

## 组合总和 II

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function (candidates, target) {
  const result = [],
    path = []
  candidates.sort((a, b) => a - b)
  function backtracking(candidates, n, startIndex = 0, sum = 0) {
    if (sum > n) {
      return
    }
    if (sum === n) {
      result.push(path.slice())
      return
    }

    for (let i = startIndex; i < candidates.length; i++) {
      if (i > startIndex && candidates[i] === candidates[i - 1]) {
        console.log(123)
        continue
      }
      path.push(candidates[i])
      sum += candidates[i]
      backtracking(candidates, n, i + 1, sum)
      sum -= candidates[i]
      path.pop()
    }
  }
  backtracking(candidates, target, 0, 0)
  return result
}
```

## 分割字符串为回文串

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
function isPail(str, l, r) {
  while (l <= r) {
    if (str[l] !== str[r]) {
      return false
    }
    l++
    r--
  }
  return true
}
var partition = function (s) {
  const result = [],
    path = []
  function backtracking(s, startIndex) {
    if (startIndex >= s.length) {
      result.push(path.slice())
      return
    }
    for (let i = startIndex; i < s.length; i++) {
      if (!isPail(s, startIndex, i)) continue
      path.push(s.slice(startIndex, i + 1))
      backtracking(s, i + 1)
      path.pop()
    }
  }
  backtracking(s, 0)
  return result
}
```

## 复原 IP

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function (s) {
  const result = []
  function backtracking(subRes, start) {
    if (subRes.length === 4 && start === s.length) {
      result.push(subRes.join("."))
      return
    }

    if (subRes.length === 4 && start < s.length) {
      return
    }

    for (let i = 1; i <= 3; i++) {
      if (start + i - 1 > s.length) {
        return
      }
      if (i !== 1 && s[start] === "0") return
      const str = s.substring(start, start + i)
      if (i === 3 && +str > 255) return

      subRes.push(str)
      backtracking(subRes, start + i)
      subRes.pop()
    }
  }
  backtracking([], 0)
  return result
}
```

## 子集

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
  const result = [],
    path = []
  function backtracking(nums, start) {
    result.push(path.slice())
    for (let i = start; i < nums.length; i++) {
      path.push(nums[i])
      backtracking(nums, i + 1)
      path.pop()
    }
  }
  backtracking(nums, 0)
  return result
}
```

## 全排列

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
  const result = [],
    path = []
  function backtracking(nums) {
    if (nums.length === path.length) {
      result.push(path.slice())
      return
    }
    for (let i = 0; i < nums.length; i++) {
      if (path.includes(nums[i])) continue
      path.push(nums[i])
      backtracking(nums)
      path.pop()
    }
  }
  backtracking(nums)
  return result
}
```

## 全排列 II

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function (nums) {
  nums.sort((a, b) => a - b)
  const result = [],
    path = []
  function backtracking(nums, used) {
    if (nums.length === path.length) {
      result.push(path.slice())
      return
    }
    for (let i = 0; i < nums.length; i++) {
      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
        continue
      }
      if (!used[i]) {
        used[i] = true
        path.push(nums[i])
        backtracking(nums, used)
        path.pop()
        used[i] = false
      }
    }
  }
  backtracking(nums, [])
  return result
}
```

# 贪心

## 分发饼干

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function (g, s) {
  g = g.sort((a, b) => a - b)
  s = s.sort((a, b) => a - b)
  let index = s.length - 1
  let count = 0
  for (let i = g.length - 1; i >= 0; i--) {
    if (index >= 0 && s[index] >= g[i]) {
      count++
      index--
    }
  }
  return count
}
```

## 摆动序列

```js
var wiggleMaxLength = function (nums) {
  if (nums.length <= 1) return nums.length
  let result = 1
  let pre = 0
  let cur = 0
  for (let i = 0; i < nums.length - 1; i++) {
    cur = nums[i + 1] - nums[i]
    if ((cur > 0 && pre <= 0) || (cur < 0 && pre >= 0)) {
      result++
      pre = cur
    }
  }
  return result
}
```

## 最大子序列和

```js
var maxSubArray = function (nums) {
  let max = nums[0]
  let dp = [nums[0]]
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(nums[i], nums[i] + dp[i - 1])
    max = Math.max(max, dp[i])
  }
  return max
}
```

## 买卖股票最佳时机 II

只要有的赚就买入

```js
var maxProfit = function (prices) {
  let max = 0
  for (let i = 1; i < prices.length; i++) {
    let temp = prices[i] - prices[i - 1]
    if (temp > 0) {
      max += temp
    }
  }
  return max
}
```

## 跳跃游戏

```js
var canJump = function (nums) {
  let start = nums.length - 1
  for (let i = nums.length - 2; i >= 0; i--) {
    if (start - i <= nums[i]) {
      start = i
    }
  }
  return start === 0
}
```

## 跳跃游戏二

https://leetcode.cn/problems/jump-game-ii/submissions/595726028/

```js
var jump = function (nums) {
  let step = 0,
    curr = nums.length - 1
  while (curr > 0) {
    for (let i = 0; i < curr; i++) {
      if (i + nums[i] >= curr) {
        curr = i
        step++
      }
    }
  }
  return step
}
```

## K 次取反之后最大化的数组和

```js
var largestSumAfterKNegations = function (nums, k) {
  for (let i = 0; i < k; i++) {
    nums.sort((a, b) => a - b)
    nums[0] = -nums[0]
  }
  const result = nums.reduce((pre, next) => pre + next, 0)
  return result
}
```

## 加油站

https://leetcode.cn/problems/gas-station/description/

```js
var canCompleteCircuit = function (gas, cost) {
  let currentSum = 0,
    totalSum = 0
  let start = 0
  for (let i = 0; i < gas.length; i++) {
    currentSum += gas[i] - cost[i]
    totalSum += gas[i] - cost[i]
    if (currentSum < 0) {
      currentSum = 0
      start = i + 1
    }
  }
  if (totalSum < 0) return -1
  return start
}
```

## 分发糖果

https://leetcode.cn/problems/candy/description/

```js
var candy = function (ratings) {
  const candys = new Array(ratings.length).fill(1)
  for (let i = 1; i < ratings.length; i++) {
    if (ratings[i] > ratings[i - 1]) {
      candys[i] = candys[i - 1] + 1
    }
  }
  for (let i = ratings.length - 2; i >= 0; i--) {
    if (ratings[i] > ratings[i + 1]) {
      candys[i] = Math.max(candys[i + 1] + 1, candys[i])
    }
  }
  const count = candys.reduce((a, b) => a + b, 0)
  // console.log()
  return count
}
```

## 柠檬水找零

```js
var lemonadeChange = function (bills) {
  const lasted = new Map()

  for (let i = 0; i < bills.length; i++) {
    if (bills[i] === 5) {
      lasted.set(5, (lasted.get(5) || 0) + 1)
    } else if (bills[i] === 10) {
      if (lasted.get(5)) {
        lasted.set(5, lasted.get(5) - 1)
        lasted.set(10, (lasted.get(10) || 0) + 1)
      } else {
        return false
      }
    } else {
      // 20 元找零
      if ((lasted.get(10) || 0) > 0 && (lasted.get(5) || 0) > 0) {
        // 优先使用 10 + 5
        lasted.set(10, lasted.get(10) - 1)
        lasted.set(5, lasted.get(5) - 1)
      } else if ((lasted.get(5) || 0) >= 3) {
        // 否则用 3 张 5 元
        lasted.set(5, lasted.get(5) - 3)
      } else {
        return false
      }
    }
  }

  return true
}
```

## 根据身高构建队列

https://leetcode.cn/problems/queue-reconstruction-by-height/description/

```js
var reconstructQueue = function (people) {
  let res = []
  people.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1]
    }
    return b[0] - a[0]
  })
  for (let i = 0; i < people.length; i++) {
    const h = people[i][0]
    const k = people[i][1]
    res.splice(k, 0, [h, k])
  }
  return res
}
```

## 合并字母区间

https://leetcode.cn/problems/partition-labels/description/

```js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function (s) {
  let hash = {}
  for (let i = 0; i < s.length; i++) {
    hash[s[i]] = i
  }
  let result = []
  let left = 0,
    right = 0
  for (let i = 0; i < s.length; i++) {
    right = Math.max(right, hash[s[i]])
    if (i === right) {
      result.push(right - left + 1)
      right++
      left = right
      continue
    }
  }

  return result
}
```

## 合并区间

https://leetcode.cn/problems/merge-intervals/

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function (intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  const result = []
  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] <= intervals[i - 1][1]) {
      intervals[i] = [
        intervals[i - 1][0],
        Math.max(intervals[i][1], intervals[i - 1][1]),
      ]
    } else {
      result.push(intervals[i - 1])
    }
  }
  result.push(intervals.pop())
  return result
}
```

## 无重叠区间

https://leetcode.cn/problems/non-overlapping-intervals/

```js
var eraseOverlapIntervals = function (intervals) {
  let count = 1
  intervals.sort((a, b) => a[1] - b[1])
  let end = intervals[0][1]
  for (let i = 1; i < intervals.length; i++) {
    const curr = intervals[i]
    if (curr[0] >= end) {
      count++
      end = curr[1]
    }
  }
  return intervals.length - count
}
```

# 动态规划

## 斐波那契而数列

```js
var fib = function (n) {
  const dp = []
  dp[0] = 0
  dp[1] = 1
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

## 爬楼梯

```js
var climbStairs = function (n) {
  const dp = []
  dp[1] = 1
  dp[2] = 2
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

## 使用最小花费爬楼梯

https://leetcode.cn/problems/min-cost-climbing-stairs/description/

```js
var minCostClimbingStairs = function (cost) {
  const dp = [0, 0]
  for (let i = 2; i <= cost.length; i++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
  }
  return dp[cost.length]
}
```

## 不同路径

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {
  const dp = new Array(m).fill(0).map((item) => new Array(n))
  for (let i = 0; i < n; i++) {
    dp[0][i] = 1
  }

  for (let i = 0; i < m; i++) {
    dp[i][0] = 1
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1]
}
```

## 不同路径二

https://leetcode.cn/problems/unique-paths-ii/description/

```js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function (obstacleGrid) {
  //判断开始是否有阻碍
  if (obstacleGrid[0][0] === 1) return 0
  const m = obstacleGrid.length
  const n = obstacleGrid[0].length
  const dp = new Array(m).fill(0).map((item) => new Array(n))
  dp[0][0] = 1
  for (let i = 1; i < m; i++) {
    dp[i][0] = obstacleGrid[i][0] === 1 || dp[i - 1][0] === 0 ? 0 : 1
  }
  for (let i = 1; i < n; i++) {
    dp[0][i] = obstacleGrid[0][i] === 1 || dp[0][i - 1] === 0 ? 0 : 1
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]
    }
  }
  console.log(dp)
  return dp[m - 1][n - 1]
}
```

## 整数拆分

https://leetcode.cn/problems/integer-break/description/

```js
var integerBreak = function (n) {
  let dp = new Array(n + 1).fill(0)
  dp[2] = 1
  for (let i = 3; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]))
    }
  }
  return dp[n]
}
```

## 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees/description/

```js
var numTrees = function (n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] = dp[j - 1] * dp[i - j] + dp[i]
    }
  }
  return dp[n]
}
```

## 分割等和子集

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function (nums) {
  let sum = nums.reduce((pre, curr) => pre + curr, 0)
  if (sum % 2 !== 0) {
    return false
  }
  sum = sum / 2
  const dp = new Array(sum + 1).fill(0)
  //物品
  for (let i = 0; i < nums.length; i++) {
    //背包
    for (let j = sum; j >= nums[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i])
      if (dp[j] === sum) {
        return true
      }
    }
  }
  return dp[sum] === sum
}
```

## 最后一块石头二

```js
var lastStoneWeightII = function (stones) {
  let sum = stones.reduce((pre, curr) => pre + curr, 0)
  let target = Math.floor(sum / 2)
  const dp = new Array(target + 1).fill(0)
  //物品
  for (let i = 0; i < stones.length; i++) {
    //背包
    for (let j = target; j >= stones[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])
    }
  }
  return sum - dp[target] - dp[target]
}
```

## 目标和

https://leetcode.cn/problems/target-sum/description/

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function (nums, target) {
  const sum = nums.reduce((pre, next) => pre + next, 0)
  const left = (sum + target) / 2
  if ((sum + target) % 2 !== 0 || sum + target < 0) {
    return 0
  }
  const dp = new Array(left + 1).fill(0)
  dp[0] = 1
  for (let i = 0; i < nums.length; i++) {
    for (let j = left; j >= nums[i]; j--) {
      dp[j] = dp[j] + dp[j - nums[i]]
    }
  }
  return dp[left]
}
```

## 一和零

https://leetcode.cn/problems/ones-and-zeroes/

```js
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
  const dp = new Array(m + 1).fill(0).map((item) => new Array(n + 1).fill(0))
  let x = 0,
    y = 0
  for (let i = 0; i < strs.length; i++) {
    //获取到他的0,1
    const [x, y] = findXY(strs[i])
    for (let j = m; j >= x; j--) {
      for (let k = n; k >= y; k--) {
        dp[j][k] = Math.max(dp[j][k], dp[j - x][k - y] + 1)
      }
    }
  }
  return dp[m][n]
}

function findXY(str) {
  let x = 0,
    y = 0
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "0") {
      x++
    } else {
      y++
    }
  }
  return [x, y]
}
```

## 完全背包

### 零钱兑换 ii

https://leetcode.cn/problems/coin-change-ii/submissions/601153084/

```js
function change(amount: number, coins: number[]): number {
  //装满容量为j的背包需要dp[j]个方法
  const dp = new Array(amount + 1).fill(0)
  //必须初始化为0,才能累加，不然累加不起来
  dp[0] = 1
  //物品
  for (let i = 0; i < coins.length; i++) {
    //容量
    for (let j = coins[i]; j <= amount; j++) {
      //遍历这些物品的容量，容量减去这个物品的容量来获取到方法数
      dp[j] = dp[j] + dp[j - coins[i]]
    }
  }
  return dp[amount]
}
```

### 组合总和 IV

https://leetcode.cn/problems/combination-sum-iv/submissions/601154586/

```js
function combinationSum4(nums: number[], target: number): number {
  //先遍历背包再遍历物品得到的是排列数，相反为组合数
  const dp = new Array(target + 1).fill(0)
  dp[0] = 1
  for (let i = 0; i <= target; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i >= nums[j]) {
        dp[i] = dp[i] + dp[i - nums[j]]
      }
    }
  }
  return dp[target]
}
```

### 零钱兑换

https://leetcode.cn/problems/coin-change/description/

```js
function coinChange(coins: number[], amount: number): number {
  const dp = new Array(amount + 1).fill(Infinity)
  dp[0] = 0
  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= amount; j++) {
      dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j])
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
}
```

### 完全平方数

https://leetcode.cn/problems/perfect-squares/description/

```js
function numSquares(n: number): number {
  const dp = new Array(n + 1).fill(0)
  for (let i = 1; i <= n; i++) {
    dp[i] = i
    for (let j = 1; i - j * j >= 0; j++) {
      dp[i] = Math.min(dp[i - j * j] + 1, dp[i])
    }
  }
  return dp[n]
}
```

### 单词拆分

https://leetcode.cn/problems/word-break/submissions/602015532/

主要是看前面那一段是否 true 和这一段是否在字典里

```js
function wordBreak(s: string, wordDict: string[]): boolean {
  const dp = new Array(s.length + 1).fill(false)
  dp[0] = true
  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < wordDict.length; j++) {
      if (
        s.slice(i - wordDict[j].length, i) === wordDict[j] &&
        dp[i - wordDict[j].length]
      ) {
        dp[i] = true
        continue
      }
    }
  }
  return dp[s.length]
}
```

### 打家劫舍

https://leetcode.cn/problems/house-robber/description/

```js
function rob(nums: number[]): number {
  const dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
  }
  return dp[nums.length - 1]
}
```

### 打家劫舍 II

https://leetcode.cn/problems/house-robber-ii/description/

```js
function rob(nums: number[]): number {
  //分成了三种情况:1.不考虑首尾元素2. 考虑首元素不考虑尾元素3. 考虑尾元素不考虑首元素
  const { length } = nums
  if (length === 0) {
    return 0
  } else if (length === 1) {
    return nums[0]
  }
  return Math.max(
    robRange(nums.slice(0, length - 1)),
    robRange(nums.slice(1, length))
  )
}

function robRange(nums) {
  const dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1]
}
```

### 打家劫舍 III

https://leetcode.cn/problems/house-robber-iii/

```js
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function rob(root: TreeNode | null): number {
  const postorder = (node) => {
    if (!node) return [0, 0]
    const left = postorder(node.left)
    const right = postorder(node.right)
    //不偷
    const noSeal = Math.max(left[0], left[1]) + Math.max(right[0], right[1])
    //偷
    const seal = node.val + left[0] + right[0]
    return [noSeal, seal]
  }
  const res = postorder(root)
  return Math.max(...res)
}
```

### 买卖股票一

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/

贪心算法

```js
function maxProfit(prices: number[]): number {
  let result = 0
  let price = prices[0]
  for (let i = 1; i < prices.length; i++) {
    result = Math.max(result, prices[i] - price)
    price = Math.min(prices[i], price)
  }
  return result
}
```

动态规划

```js
function maxProfit(prices: number[]): number {
  //dp[i][0]代表持有股票 dp[i][1]代表不持有股票
  const { length } = prices
  const dp = new Array(length).fill([0, 0])
  dp[0] = [-prices[0], 0]
  for (let i = 1; i < prices.length; i++) {
    dp[i] = [
      Math.max(dp[i - 1][0], -prices[i]),
      Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]),
    ]
  }
  return Math.max(...dp[length - 1])
}
```

### 买卖股票二

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

贪心算法

```js
function maxProfit(prices: number[]): number {
  //收割正利润利益
  let temp = 0
  let max = 0
  for (let i = 1; i < prices.length; i++) {
    temp = prices[i] - prices[i - 1]
    if (temp > 0) {
      max += temp
    }
  }
  return max
}
```

动态规划

```js
function maxProfit(prices: number[]): number {
  const { length } = prices
  const dp = new Array(length).fill([0, 0])
  dp[0] = [-prices[0], 0]
  for (let i = 1; i < length; i++) {
    dp[i] = [
      Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]),
      Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]),
    ]
  }
  return Math.max(...dp[length - 1])
}
```

### 买卖股票三

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/submissions/602070557/

```js
function maxProfit(prices: number[]): number {
  const { length } = prices
  const dp = new Array(length).fill(0).map((item) => new Array(5).fill(0))
  dp[0] = [0, -prices[0], 0, -prices[0], 0]
  for (let i = 1; i < length; i++) {
    dp[i] = [
      prices[i - 1][0],
      Math.max(dp[i - 1][1], -prices[i]),
      Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]),
      Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]),
      Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]),
    ]
  }
  return dp[length - 1][4]
}
```
